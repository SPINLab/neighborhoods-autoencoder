{"version":3,"sources":["webpack:///./js/src/img/base_one_knob.png","webpack:///./js/src/polygonMap.js","webpack:///./js/src/jogDial.js","webpack:///./js/src/efdCoefficients.js","webpack:///./js/src/main.js","webpack:///./js/src/tableRowsFromCoefficients.js","webpack:///./js/src/main.css?59e5","webpack:///./js/src/main.css","webpack:///./js/src/img/base_one_bg.png"],"names":["module","exports","__webpack_require__","p","samplePolygon","leaflet_src_default","a","polygon","animateEllipses","featureGroup","ellipses","locus","clearLayers","locusTensor","tf_esm","firstEllipse","add","ellipsesTensor","slice","length","arraySync","pointSets","transpose","timeout","drawEllipses","pointIndex","setTimeout","pointSetTensor","forEach","ellipse","ellipseIndex","ellipseTensor","centroid","offsetSum","sum","mean","ellipsePoly","color","addLayer","plotEllipse","target","line","polyline","plotLine","endpoint","_map","panTo","eachLayer","layer","setStyle","opacity","options","fillOpacity","removeLayer","JogDial","element","Instance","angleTo","self","radian","triggeredDegree","ToRad","_x","Math","cos","radius","center","x","_y","sin","y","quadrant","utils","getQuadrant","convertUnitToClock","knob","style","left","top","undefined","rotation","extend","opt","degreeStartAt","degree","info","now","old","triggerEvent","CustomEvent","MOUSE_MOVE","el","getAttribute","window","alert","Ready","Doc","document","PI","ToDeg","ModernEvent","MobileRegEx","MobileEvent","navigator","userAgent","match","PointerEvent","pointerEnabled","msPointerEnabled","Defaults","debug","touchMode","knobSize","wheelSize","zIndex","minDegree","maxDegree","DegInfo","DomEvent","MOUSE_DOWN","MOUSE_OUT","MOUSE_UP","src","key","getComputedStyle","prop","getPropertyValue","currentStyle","getCoordinates","e","rect","event","srcElement","getBoundingClientRect","targetTouches","clientX","clientY","getRotation","newDegree","delta","checkBoxCollision","bound","point","x1","x2","y1","y2","addEvent","type","handler","capture","split","i","addEventListener","attachEvent","removeEvent","removeEventListener","detachEvent","evt","createEvent","initEvent","dispatchEvent","createEventObject","fireEvent","convertClockToUnit","n","base","setAttribute","snapshot","direction","setInstance","this","KRad","WRad","WMargnLT","WMargnTP","item","BId","BW","clientWidth","BH","clientHeight","K","createElement","W","wheel","KS","WS","position","appendChild","width","height","margin","backgroundColor","filter","webkitBorderRadius","borderRadius","setDebug","setStage","mouseDragEvent","pressed","preventDefault","returnValue","offset","offsetLeft","offsetTop","atan2","mouseUpEvent","setEvents","prototype","on","listener","off","trigger","data","angle","deg","jogDial","tf","efd","order","Promise","reject","Error","nextPoints","tensor","shape","pointDistances","sub","epsilon","scalar","lengths","square","cumulativeLengths","sqrt","cumsum","zeros","concat","total_distance","max","normalizedDistances","div","mul","efdOrders","range","reshape","denominator","constants","squeeze","normDistX","matMul","normDistY","d_cos_phi","d_sin_phi","xDistances","yDistances","cos_phi","aCoeffs","bCoeffs","cCoeffs","dCoeffs","stack","array","efdOffsets","xi","squaredDiff","A0","C0","reconstructEllipses","coefficients","numberOfPoints","coeffsTensor","orders","t","linspace","orderPhases","xtAll","ytAll","map","main_map","drawnItems","main_drawnItems","reconstructionItems","main_reconstructionItems","animationItems","main_animationItems","Icon","Default","_getIconUrl","mergeOptions","iconRetinaUrl","iconUrl","shadowUrl","addTo","control","mousePosition","addControl","Control","Draw","draw","allowIntersection","showArea","rectangle","circle","marker","circlemarker","edit","setView","initMap","numEllipsesInput","getElementById","tableBody","locusBox","didUserChangeEllipsesInputManually","extractPolygon","coords","numberOfEllipses","offsets","all","then","resultsArray","value","toPrecision","innerHTML","tableRow","insertRow","coefficient","newCell","insertCell","cellContents","createTextNode","updateRows","reconstructPolygon","reconstruction","coordinates","reconstructionPolygon","drawReconstruction","console","log","Event","CREATED","drawnPoints","editing","latlngs","latLng","lat","lng","Number","catch","error","updateEllipses","layers","push","ellipsesJogDial","round","oninput","content","hmr","transform","insertInto","locals","getUrl","___CSS_LOADER_URL___0___","___CSS_LOADER_URL___1___"],"mappings":"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","file":"0.main.js","sourcesContent":["module.exports = __webpack_public_path__ + \"images/19ebf71bfa54623f9bce179b1397b1f4.png\";","import L from 'leaflet';\r\nimport 'leaflet/dist/leaflet.css';\r\nimport 'leaflet-draw';\r\nimport 'leaflet-draw/dist/leaflet.draw.css';\r\nimport 'leaflet-mouse-position';\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nconst samplePolygon = L.polygon([\r\n  [-4.042968750000001, 2.1176816099851083],\r\n  [-1.634765490889549, 4.924589343401756],\r\n  [ 2.513672411441803, 5.204741041764144],\r\n  [ 7.576171606779099, 4.854532792931999],\r\n  [ 7.576171606779099, 3.258983314545306],\r\n  [ 5.994140356779099, 1.2391610649483282],\r\n  [ 4.412109106779099, 1.5203286348304514],\r\n  [ 3.498047143220902, 2.574327983494544],\r\n  [ 1.792968884110451, 3.048365584499324],\r\n  [ 1.335937902331352, 1.4324671960870323],\r\n  [ 2.636718750000000, 0.21972602392080884],\r\n  [ 4.886719286441804, -0.008788928355074324],\r\n  [ 6.591796875000001, -1.8014609294680355],\r\n  [ 6.082030981779099, -3.188782496583868],\r\n  [ 4.130859375000001, -4.749434858640033],\r\n  [ 1.001953259110450, -3.9256363494468745],\r\n  [-2.320312634110451, -3.5923720419631144],\r\n  [-3.849609307944774, -1.5027572298285927],\r\n]);\r\n\r\nexport function initMap() {\r\n  /* This code is needed to properly load the images in the Leaflet CSS */\r\n  delete L.Icon.Default.prototype._getIconUrl;\r\n\r\n  L.Icon.Default.mergeOptions({\r\n    iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\r\n    iconUrl: require('leaflet/dist/images/marker-icon.png'),\r\n    shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\r\n  });\r\n\r\n  const map = L.map('map');\r\n\r\n  const reconstructionItems = L.featureGroup().addTo(map);\r\n  const animationItems = L.featureGroup().addTo(map);\r\n  const drawnItems = L.featureGroup().addTo(map);\r\n  drawnItems.addLayer(samplePolygon);\r\n\r\n  // Controls\r\n  L.control.mousePosition().addTo(map);\r\n  map.addControl(new L.Control.Draw({\r\n    draw: {\r\n      polygon: {\r\n        allowIntersection: false,\r\n        showArea: false\r\n      },\r\n      polyline : false,\r\n      rectangle : false,\r\n      circle : false,\r\n      marker: false,\r\n      circlemarker: false\r\n    },\r\n    edit: false\r\n  }));\r\n\r\n  const defaultCenter = [2, 0];\r\n  const defaultZoom = 5;\r\n  map.setView(defaultCenter, defaultZoom);\r\n\r\n  return {map, drawnItems, reconstructionItems, animationItems}\r\n}\r\n\r\nexport function drawReconstruction(featureGroup, coordinates) {\r\n  featureGroup.eachLayer((layer) => {\r\n    layer.setStyle({\r\n      opacity: layer.options.opacity ? layer.options.opacity * 0.3 : 0.5,\r\n      fillOpacity: layer.options.fillOpacity ? layer.options.fillOpacity * 0.3 : 0.1\r\n    })\r\n  });\r\n  const reconstructionPolygon = L.polygon(coordinates, {color: 'orange'});\r\n  featureGroup.addLayer(reconstructionPolygon);\r\n}\r\n\r\nexport function animateEllipses(featureGroup, ellipses, locus) {\r\n  featureGroup.clearLayers();\r\n\r\n  // Already add the centroid to the first polygon\r\n  const locusTensor = tf.tensor(locus);\r\n  const firstEllipse = tf.tensor([ellipses[0]])\r\n    .add(locusTensor);\r\n  // Re-assemble the offset first poly with the other polygons\r\n  const ellipsesTensor = tf.concat([\r\n    firstEllipse,\r\n    tf.tensor(ellipses.slice([1], [ellipses.length])) // auto-resolves to undefined if only one ellipse\r\n  ]);\r\n\r\n  ellipses = ellipsesTensor.arraySync();\r\n\r\n  // Draw the first polygon as is\r\n  // const ellipsePolygon = L.polygon(ellipses[0], {color: 'green'});\r\n  // featureGroup.addLayer(ellipsePolygon);\r\n  //\r\n  // Re-arrange to have list of points, each element of which contains the cooordinates for each ellipse\r\n  const pointSets = ellipsesTensor.transpose([1, 0, 2]).arraySync();\r\n  const timeout = 100;\r\n\r\n  // Iterate over the points\r\n  const pointSetIndex = 0;\r\n\r\n  function drawEllipses(pointSets, pointIndex, ellipses) {\r\n    return setTimeout(() => {\r\n      const pointSetTensor = tf.tensor(pointSets[pointIndex]);\r\n\r\n      ellipses.forEach((ellipse, ellipseIndex) => {\r\n        const ellipseTensor = tf.tensor(ellipse);\r\n        let offsetSum = tf.tensor([0, 0]);\r\n\r\n        let centroid;\r\n        if (ellipseIndex > 0) {\r\n          // Compute the offset sum of the previous ellipses\r\n          offsetSum = pointSetTensor.slice([0], [ellipseIndex])\r\n            .sum(0);\r\n          centroid = offsetSum.arraySync();\r\n        } else {\r\n          centroid = ellipseTensor.mean(0).arraySync();\r\n        }\r\n\r\n        ellipse = ellipseTensor.add(offsetSum).arraySync();\r\n        plotEllipse(featureGroup, ellipse);\r\n        plotLine(featureGroup, centroid, ellipse[pointIndex]);\r\n\r\n        let isLastEllipse = ellipseIndex === ellipses.length - 1;\r\n        if (isLastEllipse) {\r\n          let endpoint = pointSetTensor.sum(0).arraySync();\r\n          featureGroup._map.panTo(endpoint)\r\n        }\r\n      });\r\n\r\n      if (pointIndex < pointSets.length - 1){\r\n        drawEllipses(pointSets, pointIndex + 1, ellipses)\r\n      }\r\n\r\n      return featureGroup.eachLayer((layer) => {\r\n        layer.setStyle({\r\n          opacity: layer.options.opacity ? layer.options.opacity * 0.5 : 0.5,\r\n          fillOpacity: layer.options.fillOpacity ? layer.options.fillOpacity * 0.5 : 0.2\r\n        });\r\n\r\n        if (layer.options.opacity < 0.1) {\r\n          featureGroup.removeLayer(layer);\r\n        }\r\n      });\r\n    }, timeout);\r\n  }\r\n\r\n  drawEllipses(pointSets, pointSetIndex, ellipses);\r\n}\r\n\r\nfunction plotEllipse(featureGroup, ellipse) {\r\n  const ellipsePoly = L.polygon(ellipse, {color: 'green'});\r\n  featureGroup.addLayer(ellipsePoly);\r\n}\r\n\r\nfunction plotLine(featureGroup, centroid, target) {\r\n  /**\r\n   * Plots a yellow line on a feature group from a centroid to a target coordinate\r\n   */\r\n\r\n  const line = L.polyline([centroid, target], {color: 'yellow'});\r\n  return featureGroup.addLayer(line);\r\n}","// Adapted from http://www.ohsean.net/plugins/jogdial/\n\nimport './main.css';\nimport './img/base_one_bg.png';\nimport './img/base_one_knob.png';\n/*\n* JogDial.js - v 1.0\n*\n* Copyright (c) 2014 Sean Oh (ohsiwon@gmail.com)\n* Licensed under the MIT license \n*/\n\nconst JogDial = function (element, options) {\n  return new JogDial.Instance(element, options || {});\n};\n\n/*\n* Set constant values and functions\n*/\nfunction setConstants() {\n  if (JogDial.Ready) {\n    return;\n  }\n\n  // Constants\n  JogDial.Doc   = window.document;\n  JogDial.ToRad   = Math.PI / 180;\n  JogDial.ToDeg   = 180 / Math.PI;\n\n  // Detect mouse event type\n  JogDial.ModernEvent   = !!(JogDial.Doc.addEventListener);\n  JogDial.MobileRegEx   = '/Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/';\n  JogDial.MobileEvent   = ('ontouchstart' in window) && window.navigator.userAgent.match(JogDial.MobileRegEx);\n  JogDial.PointerEvent  = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled);\n\n  // Predefined options\n  JogDial.Defaults = {\n    debug : false,\n    touchMode : 'knob',  // knob | wheel\n    knobSize : '30%',\n    wheelSize : '100%',\n    zIndex : 9999,\n    degreeStartAt : 0,\n    minDegree : null,  // (null) infinity\n    maxDegree : null   // (null) infinity\n  };\n\n  // Predefined rotation info\n  JogDial.DegInfo = {\n    rotation: 0,\n    quadrant: 1\n  };\n\n  // Predefined DOM events\n  JogDial.DomEvent = {\n    MOUSE_DOWN: 'mousedown',\n    MOUSE_MOVE: 'mousemove',\n    MOUSE_OUT: 'mouseout',\n    MOUSE_UP: 'mouseup'\n  };\n\n  // Predefined custom events\n  JogDial.CustomEvent = {\n    MOUSE_DOWN: 'mousedown',\n    MOUSE_MOVE: 'mousemove',\n    MOUSE_UP: 'mouseup'\n  };\n\n  // Utilities\n  JogDial.utils  = {\n    extend : function (target, src) {\n      for (const key in src) {\n        target[key] = src[key];\n      }\n      return target;\n    },\n\n    //Return css styling\n    getComputedStyle: function (el, prop) {\n      if (window.getComputedStyle) { // W3C Standard\n        return window.getComputedStyle(el).getPropertyValue(prop);\n      }\n      else if (el.currentStyle) { // IE7 and 8\n        return el.currentStyle[prop];\n      }\n    },\n\n    //Calculating x and y coordinates\n    getCoordinates: function (e) {\n      e = e || window.event;\n      const target = e.target || e.srcElement,\n        rect = target.getBoundingClientRect(),\n        _x = ((JogDial.MobileEvent) ? e.targetTouches[0].clientX : e.clientX) - rect.left,\n        _y = ((JogDial.MobileEvent) ? e.targetTouches[0].clientY : e.clientY) - rect.top;\n      return {x:_x,y:_y};\n    },\n\n    // Return the current quadrant.\n    // Note: JogDial's Cartesian plane is flipped, hence it's returning reversed value.\n    getQuadrant: function(x, y){\n      if (x>0 && y>0) return 4;\n      else if (x<0 && y>0) return 3;\n      else if (x<0 && y<0) return 2;\n      else if (x>=0 && y<0) return 1;\n    },\n\n    // Returne the sum of rotation value\n    getRotation: function(self, quadrant, newDegree){\n      let rotation, delta = 0, info = self.info;\n      if(quadrant === 1 && info.old.quadrant === 2){ //From 360 to 0\n          delta = 360;\n        }\n        else if(quadrant === 2 && info.old.quadrant === 1){ //From 0 to 360\n          delta = -360;\n        }\n      rotation = newDegree + delta - info.old.rotation + info.now.rotation;\n      info.old.rotation = newDegree; // return 0 ~ 360\n      info.old.quadrant = quadrant; // return 1 ~ 4\n      return rotation;\n    },\n\n    //Checking collision\n    checkBoxCollision: function (bound ,point) {\n      return bound.x1 < point.x\n      && bound.x2 > point.x\n      && bound.y1 < point.y\n      && bound.y2 > point.y;\n    },\n\n    // AddEvent, cross-browser support (IE7+)\n    addEvent: function (el, type, handler, capture) {\n      type = type.split(' ');\n      for(let i=0; i < type.length; i++) {\n        if (el.addEventListener) {\n          el.addEventListener(type[i], handler, capture);\n        }\n        else if (el.attachEvent) {\n          el.attachEvent('on'+type[i], handler);\n        }\n      }\n    },\n\n    // RemoveEvent, cross-browser support (IE7+)\n    removeEvent: function (el, type, handler) {\n      type = type.split(' ');\n      for(let i=0; i < type.length; i++) {\n        if (el.addEventListener) {\n          el.removeEventListener(type[i], handler);\n        }\n        else if (el.detachEvent) {\n          el.detachEvent('on'+type[i], handler);\n        }\n      }\n    },\n\n    // triggerEvent, cross-browser support (IE7+)\n    triggerEvent: function(el, type){\n      let evt;\n      if (JogDial.Doc.createEvent) { // W3C Standard\n        evt = JogDial.Doc.createEvent(\"HTMLEvents\");\n        evt.initEvent(type, true, true);\n        el.dispatchEvent(evt);\n      }\n      else { // IE7 and 8\n        evt = JogDial.Doc.createEventObject();\n        evt.target = {};\n        JogDial.utils.extend(evt.target, el);\n        el.fireEvent('on' + type, evt);\n      }\n    },\n\n    convertClockToUnit: function (n) {\n      return n%360-90;\n    },\n\n    convertUnitToClock: function (n) {\n      return (n >= -180 && n < -90 ) ? 450+n : 90+n;\n    }\n  };\n\n  JogDial.Ready = true;\n}\n\n/**\n * Constructor\n * JogDial.Instance\n * @return  {boolean} or {JogDial.Instance}\n * @param el Html element\n * @param opt options\n */\nJogDial.Instance = function (el ,opt) {\n  // Prevent duplication\n  if (el.getAttribute('_jogDial_')) {\n    window.alert('Please Check your code:\\njogDial can not be initialized twice in a same element.');\n    return false;\n  }\n\n  // Set global contant values and functions\n  setConstants();\n\n  // Set this instance\n  setInstance(this, el, opt);\n\n  // Set stage\n  setStage(this);\n\n  // Set events\n  setEvents(this);\n\n  // Set angle\n  angleTo(this, JogDial.utils.convertClockToUnit(this.opt.degreeStartAt));\n\n  return this;\n};\n\n/*\n* Prototype inheritance\n*/\nJogDial.Instance.prototype = {\n  on: function onEvent(type, listener) {\n    JogDial.utils.addEvent(this.knob, type, listener, false);\n    return this;\n  },\n  off: function onEvent(type, listener) {\n    JogDial.utils.removeEvent(this.knob, type, listener);\n    return this;\n  },\n  trigger: function triggerEvent(type, data) {\n    if (type === 'angle') {\n      angleTo(this, JogDial.utils.convertClockToUnit(data), data);\n    } else {\n      window.alert('Please Check your code:\\njogDial does not have triggering event [' + type + ']');\n    }\n    return this;\n  },\n  angle: function angle(data) {\n    const deg = (data > this.opt.maxDegree) ? this.opt.maxDegree : data;\n    angleTo(this, JogDial.utils.convertClockToUnit(deg), deg);\n  }\n};\n\nfunction setInstance(self, el, opt){\n  self.base = el;\n  self.base.setAttribute('_JogDial_', true);\n  self.opt = JogDial.utils.extend(JogDial.utils.extend({}, JogDial.Defaults), opt);\n  self.info = {} || self;\n  self.info.now = JogDial.utils.extend({},JogDial.DegInfo);\n  self.info.old = JogDial.utils.extend({},JogDial.DegInfo);\n  self.info.snapshot = JogDial.utils.extend({},self.info);\n  self.info.snapshot.direction = null;\n}\n\nfunction setStage(self) {\n  /*\n  * Create new elements\n  * {HTMLElement}  JogDial.Instance.knob\n  * {HTMLElement}  JogDial.Instance.wheel\n  */\n  let item = {},\n    BId = self.base.getAttribute(\"id\"),\n    BW = self.base.clientWidth,\n    BH = self.base.clientHeight,\n    opt = self.opt,\n    K = item.knob = document.createElement('div'),\n    W = item.wheel = document.createElement('div'),\n    KS = K.style,\n    WS = W.style,\n    KRad, WRad, WMargnLT, WMargnTP;\n\n  //Set position property as relative if it's not predefined in Stylesheet\n  if (JogDial.utils.getComputedStyle(self.base, 'position') === 'static') {\n    self.base.style.position = 'relative';\n  }\n\n  //Append to base and extend {object} item\n  self.base.appendChild(K);\n  self.base.appendChild(W);\n  JogDial.utils.extend(self, item);\n\n  //Set global position and size\n  KS.position = WS.position = 'absolute';\n  KS.width = KS.height = opt.knobSize;\n  WS.width = WS.height = opt.wheelSize;\n\n  //Set radius value\n  KRad = K.clientWidth/2;\n  WRad = W.clientWidth/2;\n\n  //Set knob properties\n  K.setAttribute('id', BId + '_knob');\n  KS.margin = -KRad + 'px 0 0 ' + -KRad + 'px';\n  KS.zIndex = opt.zIndex;\n\n  //Set wheel properties\n  W.setAttribute('id', BId + '_wheel');\n\n  WMargnLT = (BW-W.clientWidth)/2;\n  WMargnTP = (BH-W.clientHeight)/2;\n\n  WS.left = WS.top = 0;\n  WS.margin = WMargnTP + 'px 0 0 ' + WMargnLT + 'px';\n  WS.zIndex = opt.zIndex;\n\n  //set radius and center point value\n  self.radius = WRad - KRad;\n  self.center = {x:WRad+WMargnLT, y:WRad+WMargnTP};\n\n  //Set debug mode\n  if (opt.debug) setDebug(self);\n}\n\nfunction setDebug(self) {\n  const KS = self.knob.style;\n  const WS = self.wheel.style;\n  KS.backgroundColor = '#00F';\n  WS.backgroundColor = '#0F0';\n  KS.opacity = WS.opacity = .4;\n  KS.filter = WS.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=40)';\n\n  //Fancy CSS3 for debug\n  KS.webkitBorderRadius = WS.webkitBorderRadius = \"50%\";\n  KS.borderRadius = WS.borderRadius = \"50%\";\n}\n\nfunction setEvents(self) {\n  /*\n  * Set events to control elements\n  * {HTMLElement}  JogDial.Instance.knob\n  * {HTMLElement}  JogDial.Instance.wheel\n  */\n\n  //Detect event support type and override values\n  if (JogDial.PointerEvent) { // Windows 8 touchscreen\n    JogDial.utils.extend(JogDial.DomEvent,{\n      MOUSE_DOWN: 'pointerdown MSPointerDown',\n      MOUSE_MOVE: 'pointermove MSPointerMove',\n      MOUSE_OUT: 'pointerout MSPointerOut',\n      MOUSE_UP: 'pointerup pointercancel MSPointerUp MSPointerCancel'\n    });\n  }\n  else if (JogDial.MobileEvent) { // Mobile standard\n    JogDial.utils.extend(JogDial.DomEvent,{\n      MOUSE_DOWN: 'touchstart',\n      MOUSE_MOVE: 'touchmove',\n      MOUSE_OUT: 'touchleave',\n      MOUSE_UP: 'touchend'\n    });\n  }\n\n  const opt = self.opt,\n    info = self.info,\n    K = self.knob,\n    W = self.wheel;\n  self.pressed = false;\n\n  // Add events\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_DOWN, mouseDownEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_MOVE, mouseDragEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_UP, mouseUpEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_OUT, mouseUpEvent, false);\n\n  // mouseDownEvent (MOUSE_DOWN)\n  function mouseDownEvent(e) {\n    switch (opt.touchMode) {\n      case 'knob':\n      default:\n        self.pressed = JogDial.utils.checkBoxCollision({\n          x1: K.offsetLeft - W.offsetLeft,\n          y1: K.offsetTop - W.offsetTop,\n          x2: K.offsetLeft - W.offsetLeft + K.clientWidth,\n          y2:  K.offsetTop - W.offsetTop + K.clientHeight\n          }, JogDial.utils.getCoordinates(e));\n        break;\n      case 'wheel':\n        self.pressed = true;\n        mouseDragEvent(e);\n        break;\n    }\n\n    //Trigger down event\n    if(self.pressed) JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_DOWN);\n  }\n\n  // mouseDragEvent (MOUSE_MOVE)\n  function mouseDragEvent(e) {\n    if (self.pressed) {\n      // Prevent default event\n      (e.preventDefault) ? e.preventDefault() : e.returnValue = false;\n\n      // var info = self.info, opt = self.opt,\n      let offset = JogDial.utils.getCoordinates(e),\n        _x = offset.x - self.center.x + W.offsetLeft,\n        _y = offset.y - self.center.y + W.offsetTop,\n        radian = Math.atan2(_y, _x) * JogDial.ToDeg,\n        quadrant = JogDial.utils.getQuadrant(_x, _y),\n        degree = JogDial.utils.convertUnitToClock(radian),\n        rotation;\n\n      //Calculate the current rotation value based on pointer offset\n      info.now.rotation = JogDial.utils.getRotation(self, (quadrant === undefined) ? info.old.quadrant : quadrant  , degree);\n      rotation = info.now.rotation;//Math.ceil(info.now.rotation);\n\n      if(opt.maxDegree != null && opt.maxDegree <= rotation){\n        if(info.snapshot.direction == null){\n          info.snapshot.direction = 'right';\n          info.snapshot.now = JogDial.utils.extend({},info.now);\n          info.snapshot.old = JogDial.utils.extend({},info.old);\n        }\n          rotation = opt.maxDegree;\n          radian = JogDial.utils.convertClockToUnit(rotation);\n          degree = JogDial.utils.convertUnitToClock(radian);\n      }\n      else if(opt.minDegree != null && opt.minDegree >= rotation){\n        if(info.snapshot.direction == null){\n          info.snapshot.direction = 'left';\n          info.snapshot.now = JogDial.utils.extend({},info.now);\n          info.snapshot.old = JogDial.utils.extend({},info.old);\n        }\n          rotation = opt.minDegree;\n          radian = JogDial.utils.convertClockToUnit(rotation);\n          degree = JogDial.utils.convertUnitToClock(radian);\n      }\n      else if(info.snapshot.direction != null){\n        info.snapshot.direction = null;\n      }\n\n      // Update JogDial data information\n      JogDial.utils.extend(self.knob, {\n        rotation: rotation,\n        degree: degree\n      });\n\n      // update angle\n      angleTo(self, radian);\n    }\n  }\n\n  // mouseDragEvent (MOUSE_UP, MOUSE_OUT)\n  function mouseUpEvent() {\n    if(self.pressed){\n      self.pressed = false;\n      if(self.info.snapshot.direction != null){\n        self.info.now = JogDial.utils.extend({},info.snapshot.now);\n        self.info.old = JogDial.utils.extend({},info.snapshot.old);\n        self.info.snapshot.direction = null;\n      }\n\n      // Trigger up event\n      JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_UP);\n    }\n  }\n}\n\n/*\n* Function\n* @param  {HTMLElement}    self\n* @param  {String}         radian\n*/\nfunction angleTo(self, radian, triggeredDegree) {\n  radian *= JogDial.ToRad;\n  const _x = Math.cos(radian) * self.radius + self.center.x,\n    _y = Math.sin(radian) * self.radius + self.center.y,\n    quadrant = JogDial.utils.getQuadrant(_x, _y),\n    degree = JogDial.utils.convertUnitToClock(radian);\n  self.knob.style.left = _x + 'px';\n  self.knob.style.top = _y + 'px';\n\n  if(self.knob.rotation === undefined){\n   // Update JogDial data information\n    JogDial.utils.extend(self.knob, {\n      rotation: self.opt.degreeStartAt,\n      degree: JogDial.utils.convertUnitToClock(radian)\n    });\n  }\n\n  if(triggeredDegree){\n    // Update JogDial data information\n    self.info.now = JogDial.utils.extend({},{rotation:triggeredDegree, quadrant: quadrant});\n    self.info.old = JogDial.utils.extend({},{rotation: triggeredDegree%360, quadrant: quadrant});\n    JogDial.utils.extend(self.knob, {\n      rotation: triggeredDegree,\n      degree: triggeredDegree%360\n    });\n  }\n\n  // Trigger move event\n  JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_MOVE);\n}\n\nexport default JogDial;\n","const tf = require('@tensorflow/tfjs');\r\n\r\nexport function efd(polygon, order=10) {\r\n  if (typeof order !== \"number\") return Promise.reject(new Error('Please provide an integer as order argument.'));\r\n  polygon = tf.tensor(polygon);\r\n\r\n  const nextPoints = polygon.slice([0], [polygon.shape[0] - 1]);\r\n  const pointDistances = polygon.slice([1]).sub(nextPoints);\r\n\r\n  const epsilon = tf.scalar(1e-16);\r\n\r\n  let lengths = pointDistances.square();\r\n  lengths = lengths.sum(1)\r\n    .add(epsilon)\r\n    .sqrt()\r\n    .sub(epsilon);\r\n\r\n  let cumulativeLengths = lengths.cumsum(0);\r\n  const zeros = tf.zeros([1]);\r\n  cumulativeLengths = tf.concat([zeros, cumulativeLengths]);\r\n  const total_distance = tf.max(cumulativeLengths);\r\n  let normalizedDistances = tf.div(tf.mul(Math.PI * 2, cumulativeLengths), total_distance);\r\n\r\n  const efdOrders = tf.range(1, order + 1).reshape([order, 1]);\r\n  const denominator = tf.square(efdOrders).mul(2).mul(tf.square(Math.PI));\r\n  let constants = total_distance.div(denominator);\r\n  constants = tf.squeeze(constants);\r\n  normalizedDistances = efdOrders.matMul(normalizedDistances.reshape([1, -1]));\r\n\r\n  const normDistX = normalizedDistances.slice([0, 1], [normalizedDistances.shape[0], normalizedDistances.shape[1] - 1]);\r\n  const normDistY = normalizedDistances.slice([0, 0], [normalizedDistances.shape[0], normalizedDistances.shape[1] - 1]);\r\n  const d_cos_phi = tf.cos(normDistX).sub(tf.cos(normDistY));\r\n  const d_sin_phi = tf.sin(normDistX).sub(tf.sin(normDistY));\r\n\r\n  const xDistances = pointDistances.slice([0, 0], [pointDistances.shape[0], 1]).squeeze();\r\n  const yDistances = pointDistances.slice([0, 1], [pointDistances.shape[0], 1]).squeeze();\r\n\r\n  const cos_phi = xDistances\r\n    .mul(d_cos_phi)\r\n    .div(lengths);\r\n\r\n  const aCoeffs = constants.mul(cos_phi.sum(1));\r\n\r\n  const bCoeffs = constants.mul(\r\n    xDistances.div(lengths)\r\n      .mul(d_sin_phi)\r\n      .sum(1)\r\n  );\r\n\r\n  const cCoeffs = constants.mul(\r\n    yDistances.div(lengths)\r\n      .mul(d_cos_phi)\r\n      .sum(1)\r\n  );\r\n\r\n  const dCoeffs = constants.mul(yDistances.div(lengths)\r\n    .mul(d_sin_phi)\r\n    .sum(1));\r\n\r\n  const coeffs = tf.stack([\r\n    aCoeffs,\r\n    bCoeffs,\r\n    cCoeffs,\r\n    dCoeffs\r\n  ]).transpose();\r\n\r\n  // returns a Promise\r\n  return coeffs.array()\r\n}\r\n\r\nexport function efdOffsets(polygon) {\r\n  polygon = tf.tensor(polygon);\r\n\r\n  const nextPoints = polygon.slice([0], [polygon.shape[0] - 1]);\r\n  const pointDistances = polygon.slice([1]).sub(nextPoints);\r\n\r\n  const epsilon = tf.scalar(1e-16);\r\n\r\n  let lengths = pointDistances.square();\r\n  lengths = lengths.sum(1)\r\n    .add(epsilon)\r\n    .sqrt()\r\n    .sub(epsilon);\r\n\r\n  let cumulativeLengths = lengths.cumsum(0);\r\n  const zeros = tf.zeros([1]);\r\n  cumulativeLengths = tf.concat([zeros, cumulativeLengths]);\r\n  const total_distance = tf.max(cumulativeLengths);\r\n\r\n  let xDistances = pointDistances.slice([0, 0], [pointDistances.shape[0], 1])\r\n    .squeeze();\r\n  let yDistances = pointDistances.slice([0, 1], [pointDistances.shape[0], 1])\r\n    .squeeze();\r\n\r\n  // xi = np.cumsum(dxy[:, 0]) - (dxy[:, 0] / dt) * t[1:]\r\n  const xi = xDistances.cumsum()\r\n    .sub(\r\n      xDistances.div(lengths).mul(cumulativeLengths.slice([1], [cumulativeLengths.shape[0] - 1])));\r\n\r\n  // A0 = (1 / T) * np.sum(((dxy[:, 0] / (2 * dt)) * np.diff(t ** 2)) + xi * dt)\r\n  const squaredDiff = cumulativeLengths.square()\r\n    .slice([1], [cumulativeLengths.shape[0] - 1])\r\n    .sub(\r\n      cumulativeLengths.square().slice([0], [cumulativeLengths.shape[0] - 1])\r\n    );\r\n  const A0 = tf.scalar(1.).div(total_distance).mul(\r\n    xDistances.div(tf.scalar(2.).mul(lengths))\r\n      .mul(squaredDiff)\r\n      .add(xi.mul(lengths))\r\n      .sum()\r\n  );\r\n\r\n  // delta = np.cumsum(dxy[:, 1]) - (dxy[:, 1] / dt) * t[1:]\r\n  const delta = yDistances.cumsum()\r\n    .sub(\r\n      yDistances.div(lengths)\r\n        .mul(cumulativeLengths.slice([1], cumulativeLengths.shape[0] - 1))\r\n    );\r\n\r\n  // C0 = (1 / T) * np.sum(((dxy[:, 1] / (2 * dt)) * np.diff(t ** 2)) + delta * dt)\r\n  const C0 = tf.scalar(1.).div(total_distance)\r\n    .mul(\r\n      yDistances.div(tf.scalar(2.).mul(lengths))\r\n        .mul(squaredDiff)\r\n        .add(delta.mul(lengths))\r\n        .sum()\r\n    );\r\n  //\r\n  // # A0 and CO relate to the first point of the contour array as origin.\r\n  //   # Adding those values to the coefficients to make them relate to true origin.\r\n  //   return contour[0, 0] + A0, contour[0, 1] + C0\r\n  const offsets = tf.concat([\r\n    polygon.slice([0, 0], [1, 1]).add(A0),\r\n    polygon.slice([0, 1], [1, 1]).add(C0)],\r\n    ).squeeze();\r\n  return offsets.array();\r\n}\r\n\r\nexport function reconstructEllipses(coefficients, numberOfPoints=200) {\r\n  let coeffsTensor = tf.tensor(coefficients);\r\n  const order = coeffsTensor.shape[0];\r\n  const orders = tf.range(1, order + 1).reshape([-1, 1]);\r\n\r\n  const t = tf.linspace(0, 1.0, numberOfPoints);\r\n  const orderPhases = orders.mul(tf.scalar(2))\r\n    .mul(tf.scalar(Math.PI))\r\n    .mul(t.reshape([1, -1]));\r\n\r\n  const xtAll = coeffsTensor.slice([0, 0], [coeffsTensor.shape[0], 1])\r\n    .mul(tf.cos(orderPhases))\r\n    .add(\r\n      coeffsTensor.slice([0, 1], [coeffsTensor.shape[0], 1])\r\n        .mul(tf.sin(orderPhases))\r\n    );\r\n\r\n  const ytAll = coeffsTensor.slice([0, 2], [coeffsTensor.shape[0], 1])\r\n    .mul(tf.cos(orderPhases))\r\n    .add(\r\n      coeffsTensor.slice([0, 3], [coeffsTensor.shape[0], 1])\r\n        .mul(tf.sin(orderPhases))\r\n    );\r\n\r\n  return tf.stack([xtAll, ytAll], 2);\r\n}\r\n\r\nexport function reconstructPolygon(coefficients, locus=[0., 0.], numberOfPoints=200) {\r\n  const locusTensor = tf.tensor(locus);\r\n  const ellipses = reconstructEllipses(coefficients, numberOfPoints);\r\n\r\n  const reconstruction = ellipses.sum(0)\r\n      .add(locusTensor);\r\n  return reconstruction.array();\r\n}","import {initMap, drawReconstruction, animateEllipses} from './polygonMap';\r\nimport JogDial from './jogDial';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport 'bootstrap';\r\nimport L from \"leaflet\";\r\nimport {efd, efdOffsets, reconstructPolygon, reconstructEllipses} from \"./efdCoefficients\";\r\nimport updateRows from \"./tableRowsFromCoefficients\";\r\n\r\nconst {map, drawnItems, reconstructionItems, animationItems} = initMap();\r\nconst numEllipsesInput = document.getElementById('num_ellipses');\r\nconst tableBody = document.getElementById('coefficients_table_body');\r\nconst locusBox = document.getElementById('locus');\r\n\r\nlet didUserChangeEllipsesInputManually = false;\r\n\r\nfunction extractPolygon(coords, numberOfEllipses) {\r\n  let offsets, coefficients;\r\n  const numberOfPoints = 200;\r\n\r\n  return Promise.all([\r\n    efdOffsets(coords),\r\n    efd(coords, numberOfEllipses)\r\n  ]).then((resultsArray) => {\r\n    [offsets, coefficients] = resultsArray;\r\n    locusBox.value = offsets.map(offset => offset.toPrecision(6));\r\n    updateRows(tableBody, coefficients);\r\n    // const numberOfPoints = coords.length;\r\n    return reconstructPolygon(coefficients, offsets, numberOfPoints);\r\n  })\r\n    .then((reconstruction) => drawReconstruction(reconstructionItems, reconstruction))\r\n    // Get the individual ellipses\r\n    .then(() => reconstructEllipses(coefficients, numberOfPoints))\r\n    .then((ellipses) => ellipses.array())\r\n    .then((ellipses) => {\r\n      console.log(ellipses);\r\n      animateEllipses(animationItems, ellipses, offsets)\r\n    })\r\n  // ;\r\n}\r\n\r\nmap.on(L.Draw.Event.CREATED, (event) => {\r\n  drawnItems.eachLayer((layer) => drawnItems.removeLayer(layer));\r\n  const layer = event.layer;\r\n  drawnItems.addLayer(layer);\r\n\r\n  const drawnPoints = event.layer.editing.latlngs[0][0]\r\n    .map(latLng => [latLng.lat, latLng.lng]);\r\n\r\n  const numberOfEllipses = Number(numEllipsesInput.value);\r\n\r\n  return extractPolygon(drawnPoints, numberOfEllipses, drawnPoints)\r\n    .then(() => console.log('Done'))\r\n    .catch(console.error)\r\n});\r\n\r\n// Construct and register ellipses jog dial\r\nconst options = {\r\n  debug: false,\r\n  wheelSize: \"80%\",\r\n  minDegree: 1,\r\n  maxDegree: 99999\r\n};\r\n\r\nconst ellipsesJogDialElement = document.getElementById('ellipses_jog_dial');\r\n// const coefficientHeadingElement = document.getElementById('coefficient_heading');\r\n\r\nfunction updateEllipses(numberOfEllipses) {\r\n  // coefficientHeadingElement.innerText = 'Ellipsis coefficients (working)';\r\n  numEllipsesInput.value = numberOfEllipses;\r\n\r\n  let layers = [];\r\n  drawnItems.eachLayer((layer) => layers.push(layer));\r\n  const drawnPoints = layers[0].editing.latlngs[0][0]\r\n    .map(latLng => [latLng.lat, latLng.lng]);\r\n\r\n  drawnPoints.push(drawnPoints[0]); // Append start->closing point to create fully closed polygon contour\r\n\r\n  return extractPolygon(drawnPoints, numberOfEllipses)\r\n}\r\n\r\nconst ellipsesJogDial = JogDial(ellipsesJogDialElement, options)\r\n  .on(\"mouseup\", (event) => {\r\n    const numberOfEllipses = Math.round(event.target.rotation * 0.25);\r\n\r\n    return updateEllipses(numberOfEllipses)\r\n      .then(() => console.log('Done'))\r\n      .catch(console.error);\r\n  })\r\n  .on( \"mousemove\", (event) => {\r\n    if (!didUserChangeEllipsesInputManually) {\r\n      numEllipsesInput.value = Math.round(event.target.rotation * 0.25);\r\n    }\r\n    didUserChangeEllipsesInputManually = false;\r\n  });\r\n\r\nnumEllipsesInput.oninput = () => {\r\n  didUserChangeEllipsesInputManually = true;\r\n  const numberOfEllipses = Number(numEllipsesInput.value);\r\n  ellipsesJogDial.angle(numberOfEllipses * 4);\r\n\r\n  return updateEllipses(numberOfEllipses)\r\n    .catch(console.error);\r\n};\r\n","export default function updateRows(tableBody, coefficients) {\r\n  tableBody.innerHTML = '';\r\n\r\n  return coefficients.forEach((ellipse) => {\r\n    const tableRow = tableBody.insertRow();\r\n\r\n    return ellipse.forEach((coefficient) => {\r\n      const newCell = tableRow.insertCell(-1);\r\n      const cellContents = document.createTextNode(coefficient.toPrecision(8));\r\n      newCell.appendChild(cellContents);\r\n    });\r\n  });\r\n}\r\n","\nvar content = require(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Imports\nvar getUrl = require(\"../../node_modules/css-loader/dist/runtime/getUrl.js\");\nvar ___CSS_LOADER_URL___0___ = getUrl(require(\"./img/base_one_bg.png\"));\nvar ___CSS_LOADER_URL___1___ = getUrl(require(\"./img/base_one_knob.png\"));\n// Module\nexports.push([module.id, \"#dials {\\r\\n    height: 320px;\\r\\n    overflow: hidden;\\r\\n}\\r\\n\\r\\n.dial {\\r\\n    display: block;\\r\\n    position: relative;\\r\\n    height: 320px;\\r\\n}\\r\\n\\r\\n.dial.hidden {\\r\\n    display: none;\\r\\n}\\r\\n\\r\\n#ellipses_jog_dial {\\r\\n    position: relative;\\r\\n    width: 260px;\\r\\n    height: 260px;\\r\\n    margin: 20px auto;\\r\\n    background: url(\" + ___CSS_LOADER_URL___0___ + \") no-repeat;\\r\\n}\\r\\n#ellipses_jog_dial #ellipses_jog_dial_knob {\\r\\n    background: url(\" + ___CSS_LOADER_URL___1___ + \") no-repeat;\\r\\n}\\r\\n\", \"\"]);\n","module.exports = __webpack_public_path__ + \"images/558502491546f3959097267749723121.png\";"],"sourceRoot":""}