{"version":3,"sources":["webpack:///./js/src/img/base_one_knob.png","webpack:///./js/src/polygonMap.js","webpack:///./js/src/jogDial.js","webpack:///./js/src/efdCoefficients.js","webpack:///./js/src/extractPolygon.js","webpack:///./js/src/tableRowsFromCoefficients.js","webpack:///./js/src/main.js","webpack:///./js/src/main.css?59e5","webpack:///./js/src/main.css","webpack:///./js/src/img/base_one_bg.png"],"names":["module","exports","__webpack_require__","p","samplePolygon","leaflet_src_default","a","polygon","drawReconstruction","coordinates","featureGroup","window","reconstructionItems","eachLayer","layer","setStyle","opacity","options","fillOpacity","reconstructionPolygon","color","addLayer","animateEllipses","ellipses","locus","clearLayers","locusTensor","tf_esm","firstEllipse","add","ellipsesTensor","slice","length","arraySync","pointSets","transpose","timeout","drawEllipses","pointIndex","document","getElementById","checked","setTimeout","pointSetTensor","forEach","ellipse","ellipseIndex","ellipseTensor","centroid","offsetSum","sum","mean","ellipsePoly","plotEllipse","target","line","polyline","plotLine","endpoint","_map","panTo","removeLayer","JogDial","element","Instance","angleTo","self","radian","triggeredDegree","ToRad","_x","Math","cos","radius","center","x","_y","sin","y","quadrant","utils","getQuadrant","convertUnitToClock","knob","style","left","top","undefined","rotation","extend","opt","degreeStartAt","degree","info","now","old","triggerEvent","CustomEvent","MOUSE_MOVE","el","getAttribute","alert","Ready","Doc","PI","ToDeg","ModernEvent","MobileRegEx","MobileEvent","navigator","userAgent","match","PointerEvent","pointerEnabled","msPointerEnabled","Defaults","debug","touchMode","knobSize","wheelSize","zIndex","minDegree","maxDegree","DegInfo","DomEvent","MOUSE_DOWN","MOUSE_OUT","MOUSE_UP","src","key","getComputedStyle","prop","getPropertyValue","currentStyle","getCoordinates","e","rect","event","srcElement","getBoundingClientRect","targetTouches","clientX","clientY","getRotation","newDegree","delta","checkBoxCollision","bound","point","x1","x2","y1","y2","addEvent","type","handler","capture","split","i","addEventListener","attachEvent","removeEvent","removeEventListener","detachEvent","evt","createEvent","initEvent","dispatchEvent","createEventObject","fireEvent","convertClockToUnit","n","base","setAttribute","snapshot","direction","setInstance","this","KRad","WRad","WMargnLT","WMargnTP","item","BId","BW","clientWidth","BH","clientHeight","K","createElement","W","wheel","KS","WS","position","appendChild","width","height","margin","backgroundColor","filter","webkitBorderRadius","borderRadius","setDebug","setStage","mouseDragEvent","pressed","preventDefault","returnValue","offset","offsetLeft","offsetTop","atan2","mouseUpEvent","setEvents","prototype","on","listener","off","trigger","data","angle","deg","jogDial","tf","efd","order","Promise","reject","Error","nextPoints","tensor","shape","pointDistances","sub","epsilon","scalar","lengths","square","cumulativeLengths","sqrt","cumsum","zeros","concat","total_distance","max","normalizedDistances","div","mul","efdOrders","range","reshape","denominator","constants","squeeze","normDistX","matMul","normDistY","d_cos_phi","d_sin_phi","xDistances","yDistances","cos_phi","aCoeffs","bCoeffs","cCoeffs","dCoeffs","stack","array","efdOffsets","xi","squaredDiff","A0","C0","reconstructEllipses","coefficients","numberOfPoints","coeffsTensor","orders","t","linspace","orderPhases","xtAll","ytAll","reconstructPolygon","extractPolygon","coords","numberOfEllipses","locusBox","tableBody","offsets","all","then","resultsArray","value","map","toPrecision","innerHTML","tableRow","insertRow","coefficient","insertCell","updateRows","reconstruction","animationItems","catch","console","error","updateTableEvent","tableRows","querySelectorAll","Number","row","rowInputs","ellipseCoeffs","Array","from","input","push","main_map","drawnItems","main_drawnItems","main_reconstructionItems","main_animationItems","Icon","Default","_getIconUrl","mergeOptions","iconRetinaUrl","iconUrl","shadowUrl","addTo","control","mousePosition","addControl","Control","Draw","draw","allowIntersection","showArea","rectangle","circle","marker","circlemarker","edit","setView","initMap","numEllipsesInput","didUserChangeEllipsesInputManually","Event","CREATED","editing","latlngs","latLng","lat","lng","log","updateEllipses","layers","drawnPoints","ellipsesJogDial","round","oninput","content","hmr","transform","insertInto","locals","getUrl","___CSS_LOADER_URL___0___","___CSS_LOADER_URL___1___"],"mappings":"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","file":"0.main.js","sourcesContent":["module.exports = __webpack_public_path__ + \"images/19ebf71bfa54623f9bce179b1397b1f4.png\";","import L from 'leaflet';\r\nimport 'leaflet/dist/leaflet.css';\r\nimport 'leaflet-draw';\r\nimport 'leaflet-draw/dist/leaflet.draw.css';\r\nimport 'leaflet-mouse-position';\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nconst samplePolygon = L.polygon([\r\n  [-4.042968750000001, 2.1176816099851083],\r\n  [-1.634765490889549, 4.924589343401756],\r\n  [ 2.513672411441803, 5.204741041764144],\r\n  [ 7.576171606779099, 4.854532792931999],\r\n  [ 7.576171606779099, 3.258983314545306],\r\n  [ 5.994140356779099, 1.2391610649483282],\r\n  [ 4.412109106779099, 1.5203286348304514],\r\n  [ 3.498047143220902, 2.574327983494544],\r\n  [ 1.792968884110451, 3.048365584499324],\r\n  [ 1.335937902331352, 1.4324671960870323],\r\n  [ 2.636718750000000, 0.21972602392080884],\r\n  [ 4.886719286441804, -0.008788928355074324],\r\n  [ 6.591796875000001, -1.8014609294680355],\r\n  [ 6.082030981779099, -3.188782496583868],\r\n  [ 4.130859375000001, -4.749434858640033],\r\n  [ 1.001953259110450, -3.9256363494468745],\r\n  [-2.320312634110451, -3.5923720419631144],\r\n  [-3.849609307944774, -1.5027572298285927],\r\n]);\r\n\r\nexport function initMap() {\r\n  /* This code is needed to properly load the images in the Leaflet CSS */\r\n  delete L.Icon.Default.prototype._getIconUrl;\r\n\r\n  L.Icon.Default.mergeOptions({\r\n    iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\r\n    iconUrl: require('leaflet/dist/images/marker-icon.png'),\r\n    shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\r\n  });\r\n\r\n  const map = L.map('map');\r\n\r\n  const reconstructionItems = L.featureGroup().addTo(map);\r\n  const animationItems = L.featureGroup().addTo(map);\r\n  const drawnItems = L.featureGroup().addTo(map);\r\n  drawnItems.addLayer(samplePolygon);\r\n\r\n  // Controls\r\n  L.control.mousePosition().addTo(map);\r\n  map.addControl(new L.Control.Draw({\r\n    draw: {\r\n      polygon: {\r\n        allowIntersection: false,\r\n        showArea: false\r\n      },\r\n      polyline : false,\r\n      rectangle : false,\r\n      circle : false,\r\n      marker: false,\r\n      circlemarker: false\r\n    },\r\n    edit: false\r\n  }));\r\n\r\n  const defaultCenter = [2, 0];\r\n  const defaultZoom = 5;\r\n  map.setView(defaultCenter, defaultZoom);\r\n\r\n  return {map, drawnItems, reconstructionItems, animationItems}\r\n}\r\n\r\nexport function drawReconstruction(coordinates) {\r\n  const featureGroup = window.reconstructionItems;\r\n\r\n  featureGroup.eachLayer((layer) => {\r\n    layer.setStyle({\r\n      opacity: layer.options.opacity ? layer.options.opacity * 0.3 : 0.5,\r\n      fillOpacity: layer.options.fillOpacity ? layer.options.fillOpacity * 0.3 : 0.1\r\n    })\r\n  });\r\n  const reconstructionPolygon = L.polygon(coordinates, {color: 'orange'});\r\n  featureGroup.addLayer(reconstructionPolygon);\r\n}\r\n\r\nexport function animateEllipses(featureGroup, ellipses, locus) {\r\n  featureGroup.clearLayers();\r\n\r\n  // Already add the centroid to the first polygon\r\n  const locusTensor = tf.tensor(locus);\r\n  const firstEllipse = tf.tensor([ellipses[0]])\r\n    .add(locusTensor);\r\n  // Re-assemble the offset first poly with the other polygons\r\n  const ellipsesTensor = tf.concat([\r\n    firstEllipse,\r\n    tf.tensor(ellipses.slice([1], [ellipses.length])) // auto-resolves to undefined if only one ellipse\r\n  ]);\r\n\r\n  ellipses = ellipsesTensor.arraySync();\r\n\r\n  // Draw the first polygon as is\r\n  // const ellipsePolygon = L.polygon(ellipses[0], {color: 'green'});\r\n  // featureGroup.addLayer(ellipsePolygon);\r\n  //\r\n  // Re-arrange to have list of points, each element of which contains the cooordinates for each ellipse\r\n  const pointSets = ellipsesTensor.transpose([1, 0, 2]).arraySync();\r\n  const timeout = 100;\r\n\r\n  // Iterate over the points\r\n  const pointSetIndex = 0;\r\n\r\n  function drawEllipses(pointSets, pointIndex, ellipses) {\r\n    const doDraw = document.getElementById('animate_reconstruction').checked;\r\n    if (!doDraw) { return; }  // Break recursion loop if the user has disabled the animation\r\n\r\n    return setTimeout(() => {\r\n      const pointSetTensor = tf.tensor(pointSets[pointIndex]);\r\n\r\n      ellipses.forEach((ellipse, ellipseIndex) => {\r\n        const ellipseTensor = tf.tensor(ellipse);\r\n        let offsetSum = tf.tensor([0, 0]);\r\n\r\n        let centroid;\r\n        if (ellipseIndex > 0) {\r\n          // Compute the offset sum of the previous ellipses\r\n          offsetSum = pointSetTensor.slice([0], [ellipseIndex])\r\n            .sum(0);\r\n          centroid = offsetSum.arraySync();\r\n        } else {\r\n          centroid = ellipseTensor.mean(0).arraySync();\r\n        }\r\n\r\n        ellipse = ellipseTensor.add(offsetSum).arraySync();\r\n        plotEllipse(featureGroup, ellipse);\r\n        plotLine(featureGroup, centroid, ellipse[pointIndex]);\r\n\r\n        let isLastEllipse = ellipseIndex === ellipses.length - 1;\r\n        if (isLastEllipse) {\r\n          const followReconstruction = document.getElementById('follow_reconstruction').checked;\r\n\r\n          if (followReconstruction) {\r\n            const endpoint = pointSetTensor.sum(0).arraySync();\r\n            featureGroup._map.panTo(endpoint);\r\n          }\r\n        }\r\n      });\r\n\r\n      if (pointIndex < pointSets.length - 1){\r\n        drawEllipses(pointSets, pointIndex + 1, ellipses)\r\n      }\r\n\r\n      return featureGroup.eachLayer((layer) => {\r\n        layer.setStyle({\r\n          opacity: layer.options.opacity ? layer.options.opacity * 0.5 : 0.5,\r\n          fillOpacity: layer.options.fillOpacity ? layer.options.fillOpacity * 0.5 : 0.2\r\n        });\r\n\r\n        if (layer.options.opacity < 0.1) {\r\n          featureGroup.removeLayer(layer);\r\n        }\r\n      });\r\n    }, timeout);\r\n  }\r\n\r\n  drawEllipses(pointSets, pointSetIndex, ellipses);\r\n}\r\n\r\nfunction plotEllipse(featureGroup, ellipse) {\r\n  const ellipsePoly = L.polygon(ellipse, {color: 'green'});\r\n  featureGroup.addLayer(ellipsePoly);\r\n}\r\n\r\nfunction plotLine(featureGroup, centroid, target) {\r\n  /**\r\n   * Plots a yellow line on a feature group from a centroid to a target coordinate\r\n   */\r\n\r\n  const line = L.polyline([centroid, target], {color: 'yellow'});\r\n  return featureGroup.addLayer(line);\r\n}","// Adapted from http://www.ohsean.net/plugins/jogdial/\n\nimport './main.css';\nimport './img/base_one_bg.png';\nimport './img/base_one_knob.png';\n/*\n* JogDial.js - v 1.0\n*\n* Copyright (c) 2014 Sean Oh (ohsiwon@gmail.com)\n* Licensed under the MIT license \n*/\n\nconst JogDial = function (element, options) {\n  return new JogDial.Instance(element, options || {});\n};\n\n/*\n* Set constant values and functions\n*/\nfunction setConstants() {\n  if (JogDial.Ready) {\n    return;\n  }\n\n  // Constants\n  JogDial.Doc   = window.document;\n  JogDial.ToRad   = Math.PI / 180;\n  JogDial.ToDeg   = 180 / Math.PI;\n\n  // Detect mouse event type\n  JogDial.ModernEvent   = !!(JogDial.Doc.addEventListener);\n  JogDial.MobileRegEx   = '/Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/';\n  JogDial.MobileEvent   = ('ontouchstart' in window) && window.navigator.userAgent.match(JogDial.MobileRegEx);\n  JogDial.PointerEvent  = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled);\n\n  // Predefined options\n  JogDial.Defaults = {\n    debug : false,\n    touchMode : 'knob',  // knob | wheel\n    knobSize : '30%',\n    wheelSize : '100%',\n    zIndex : 9999,\n    degreeStartAt : 0,\n    minDegree : null,  // (null) infinity\n    maxDegree : null   // (null) infinity\n  };\n\n  // Predefined rotation info\n  JogDial.DegInfo = {\n    rotation: 0,\n    quadrant: 1\n  };\n\n  // Predefined DOM events\n  JogDial.DomEvent = {\n    MOUSE_DOWN: 'mousedown',\n    MOUSE_MOVE: 'mousemove',\n    MOUSE_OUT: 'mouseout',\n    MOUSE_UP: 'mouseup'\n  };\n\n  // Predefined custom events\n  JogDial.CustomEvent = {\n    MOUSE_DOWN: 'mousedown',\n    MOUSE_MOVE: 'mousemove',\n    MOUSE_UP: 'mouseup'\n  };\n\n  // Utilities\n  JogDial.utils  = {\n    extend : function (target, src) {\n      for (const key in src) {\n        target[key] = src[key];\n      }\n      return target;\n    },\n\n    //Return css styling\n    getComputedStyle: function (el, prop) {\n      if (window.getComputedStyle) { // W3C Standard\n        return window.getComputedStyle(el).getPropertyValue(prop);\n      }\n      else if (el.currentStyle) { // IE7 and 8\n        return el.currentStyle[prop];\n      }\n    },\n\n    //Calculating x and y coordinates\n    getCoordinates: function (e) {\n      e = e || window.event;\n      const target = e.target || e.srcElement,\n        rect = target.getBoundingClientRect(),\n        _x = ((JogDial.MobileEvent) ? e.targetTouches[0].clientX : e.clientX) - rect.left,\n        _y = ((JogDial.MobileEvent) ? e.targetTouches[0].clientY : e.clientY) - rect.top;\n      return {x:_x,y:_y};\n    },\n\n    // Return the current quadrant.\n    // Note: JogDial's Cartesian plane is flipped, hence it's returning reversed value.\n    getQuadrant: function(x, y){\n      if (x>0 && y>0) return 4;\n      else if (x<0 && y>0) return 3;\n      else if (x<0 && y<0) return 2;\n      else if (x>=0 && y<0) return 1;\n    },\n\n    // Returne the sum of rotation value\n    getRotation: function(self, quadrant, newDegree){\n      let rotation, delta = 0, info = self.info;\n      if(quadrant === 1 && info.old.quadrant === 2){ //From 360 to 0\n          delta = 360;\n        }\n        else if(quadrant === 2 && info.old.quadrant === 1){ //From 0 to 360\n          delta = -360;\n        }\n      rotation = newDegree + delta - info.old.rotation + info.now.rotation;\n      info.old.rotation = newDegree; // return 0 ~ 360\n      info.old.quadrant = quadrant; // return 1 ~ 4\n      return rotation;\n    },\n\n    //Checking collision\n    checkBoxCollision: function (bound ,point) {\n      return bound.x1 < point.x\n      && bound.x2 > point.x\n      && bound.y1 < point.y\n      && bound.y2 > point.y;\n    },\n\n    // AddEvent, cross-browser support (IE7+)\n    addEvent: function (el, type, handler, capture) {\n      type = type.split(' ');\n      for(let i=0; i < type.length; i++) {\n        if (el.addEventListener) {\n          el.addEventListener(type[i], handler, capture);\n        }\n        else if (el.attachEvent) {\n          el.attachEvent('on'+type[i], handler);\n        }\n      }\n    },\n\n    // RemoveEvent, cross-browser support (IE7+)\n    removeEvent: function (el, type, handler) {\n      type = type.split(' ');\n      for(let i=0; i < type.length; i++) {\n        if (el.addEventListener) {\n          el.removeEventListener(type[i], handler);\n        }\n        else if (el.detachEvent) {\n          el.detachEvent('on'+type[i], handler);\n        }\n      }\n    },\n\n    // triggerEvent, cross-browser support (IE7+)\n    triggerEvent: function(el, type){\n      let evt;\n      if (JogDial.Doc.createEvent) { // W3C Standard\n        evt = JogDial.Doc.createEvent(\"HTMLEvents\");\n        evt.initEvent(type, true, true);\n        el.dispatchEvent(evt);\n      }\n      else { // IE7 and 8\n        evt = JogDial.Doc.createEventObject();\n        evt.target = {};\n        JogDial.utils.extend(evt.target, el);\n        el.fireEvent('on' + type, evt);\n      }\n    },\n\n    convertClockToUnit: function (n) {\n      return n%360-90;\n    },\n\n    convertUnitToClock: function (n) {\n      return (n >= -180 && n < -90 ) ? 450+n : 90+n;\n    }\n  };\n\n  JogDial.Ready = true;\n}\n\n/**\n * Constructor\n * JogDial.Instance\n * @return  {boolean} or {JogDial.Instance}\n * @param el Html element\n * @param opt options\n */\nJogDial.Instance = function (el ,opt) {\n  // Prevent duplication\n  if (el.getAttribute('_jogDial_')) {\n    window.alert('Please Check your code:\\njogDial can not be initialized twice in a same element.');\n    return false;\n  }\n\n  // Set global contant values and functions\n  setConstants();\n\n  // Set this instance\n  setInstance(this, el, opt);\n\n  // Set stage\n  setStage(this);\n\n  // Set events\n  setEvents(this);\n\n  // Set angle\n  angleTo(this, JogDial.utils.convertClockToUnit(this.opt.degreeStartAt));\n\n  return this;\n};\n\n/*\n* Prototype inheritance\n*/\nJogDial.Instance.prototype = {\n  on: function onEvent(type, listener) {\n    JogDial.utils.addEvent(this.knob, type, listener, false);\n    return this;\n  },\n  off: function onEvent(type, listener) {\n    JogDial.utils.removeEvent(this.knob, type, listener);\n    return this;\n  },\n  trigger: function triggerEvent(type, data) {\n    if (type === 'angle') {\n      angleTo(this, JogDial.utils.convertClockToUnit(data), data);\n    } else {\n      window.alert('Please Check your code:\\njogDial does not have triggering event [' + type + ']');\n    }\n    return this;\n  },\n  angle: function angle(data) {\n    const deg = (data > this.opt.maxDegree) ? this.opt.maxDegree : data;\n    angleTo(this, JogDial.utils.convertClockToUnit(deg), deg);\n  }\n};\n\nfunction setInstance(self, el, opt){\n  self.base = el;\n  self.base.setAttribute('_JogDial_', true);\n  self.opt = JogDial.utils.extend(JogDial.utils.extend({}, JogDial.Defaults), opt);\n  self.info = {} || self;\n  self.info.now = JogDial.utils.extend({},JogDial.DegInfo);\n  self.info.old = JogDial.utils.extend({},JogDial.DegInfo);\n  self.info.snapshot = JogDial.utils.extend({},self.info);\n  self.info.snapshot.direction = null;\n}\n\nfunction setStage(self) {\n  /*\n  * Create new elements\n  * {HTMLElement}  JogDial.Instance.knob\n  * {HTMLElement}  JogDial.Instance.wheel\n  */\n  let item = {},\n    BId = self.base.getAttribute(\"id\"),\n    BW = self.base.clientWidth,\n    BH = self.base.clientHeight,\n    opt = self.opt,\n    K = item.knob = document.createElement('div'),\n    W = item.wheel = document.createElement('div'),\n    KS = K.style,\n    WS = W.style,\n    KRad, WRad, WMargnLT, WMargnTP;\n\n  //Set position property as relative if it's not predefined in Stylesheet\n  if (JogDial.utils.getComputedStyle(self.base, 'position') === 'static') {\n    self.base.style.position = 'relative';\n  }\n\n  //Append to base and extend {object} item\n  self.base.appendChild(K);\n  self.base.appendChild(W);\n  JogDial.utils.extend(self, item);\n\n  //Set global position and size\n  KS.position = WS.position = 'absolute';\n  KS.width = KS.height = opt.knobSize;\n  WS.width = WS.height = opt.wheelSize;\n\n  //Set radius value\n  KRad = K.clientWidth/2;\n  WRad = W.clientWidth/2;\n\n  //Set knob properties\n  K.setAttribute('id', BId + '_knob');\n  KS.margin = -KRad + 'px 0 0 ' + -KRad + 'px';\n  KS.zIndex = opt.zIndex;\n\n  //Set wheel properties\n  W.setAttribute('id', BId + '_wheel');\n\n  WMargnLT = (BW-W.clientWidth)/2;\n  WMargnTP = (BH-W.clientHeight)/2;\n\n  WS.left = WS.top = 0;\n  WS.margin = WMargnTP + 'px 0 0 ' + WMargnLT + 'px';\n  WS.zIndex = opt.zIndex;\n\n  //set radius and center point value\n  self.radius = WRad - KRad;\n  self.center = {x:WRad+WMargnLT, y:WRad+WMargnTP};\n\n  //Set debug mode\n  if (opt.debug) setDebug(self);\n}\n\nfunction setDebug(self) {\n  const KS = self.knob.style;\n  const WS = self.wheel.style;\n  KS.backgroundColor = '#00F';\n  WS.backgroundColor = '#0F0';\n  KS.opacity = WS.opacity = .4;\n  KS.filter = WS.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=40)';\n\n  //Fancy CSS3 for debug\n  KS.webkitBorderRadius = WS.webkitBorderRadius = \"50%\";\n  KS.borderRadius = WS.borderRadius = \"50%\";\n}\n\nfunction setEvents(self) {\n  /*\n  * Set events to control elements\n  * {HTMLElement}  JogDial.Instance.knob\n  * {HTMLElement}  JogDial.Instance.wheel\n  */\n\n  //Detect event support type and override values\n  if (JogDial.PointerEvent) { // Windows 8 touchscreen\n    JogDial.utils.extend(JogDial.DomEvent,{\n      MOUSE_DOWN: 'pointerdown MSPointerDown',\n      MOUSE_MOVE: 'pointermove MSPointerMove',\n      MOUSE_OUT: 'pointerout MSPointerOut',\n      MOUSE_UP: 'pointerup pointercancel MSPointerUp MSPointerCancel'\n    });\n  }\n  else if (JogDial.MobileEvent) { // Mobile standard\n    JogDial.utils.extend(JogDial.DomEvent,{\n      MOUSE_DOWN: 'touchstart',\n      MOUSE_MOVE: 'touchmove',\n      MOUSE_OUT: 'touchleave',\n      MOUSE_UP: 'touchend'\n    });\n  }\n\n  const opt = self.opt,\n    info = self.info,\n    K = self.knob,\n    W = self.wheel;\n  self.pressed = false;\n\n  // Add events\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_DOWN, mouseDownEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_MOVE, mouseDragEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_UP, mouseUpEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_OUT, mouseUpEvent, false);\n\n  // mouseDownEvent (MOUSE_DOWN)\n  function mouseDownEvent(e) {\n    switch (opt.touchMode) {\n      case 'knob':\n      default:\n        self.pressed = JogDial.utils.checkBoxCollision({\n          x1: K.offsetLeft - W.offsetLeft,\n          y1: K.offsetTop - W.offsetTop,\n          x2: K.offsetLeft - W.offsetLeft + K.clientWidth,\n          y2:  K.offsetTop - W.offsetTop + K.clientHeight\n          }, JogDial.utils.getCoordinates(e));\n        break;\n      case 'wheel':\n        self.pressed = true;\n        mouseDragEvent(e);\n        break;\n    }\n\n    //Trigger down event\n    if(self.pressed) JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_DOWN);\n  }\n\n  // mouseDragEvent (MOUSE_MOVE)\n  function mouseDragEvent(e) {\n    if (self.pressed) {\n      // Prevent default event\n      (e.preventDefault) ? e.preventDefault() : e.returnValue = false;\n\n      // var info = self.info, opt = self.opt,\n      let offset = JogDial.utils.getCoordinates(e),\n        _x = offset.x - self.center.x + W.offsetLeft,\n        _y = offset.y - self.center.y + W.offsetTop,\n        radian = Math.atan2(_y, _x) * JogDial.ToDeg,\n        quadrant = JogDial.utils.getQuadrant(_x, _y),\n        degree = JogDial.utils.convertUnitToClock(radian),\n        rotation;\n\n      //Calculate the current rotation value based on pointer offset\n      info.now.rotation = JogDial.utils.getRotation(self, (quadrant === undefined) ? info.old.quadrant : quadrant  , degree);\n      rotation = info.now.rotation;//Math.ceil(info.now.rotation);\n\n      if(opt.maxDegree != null && opt.maxDegree <= rotation){\n        if(info.snapshot.direction == null){\n          info.snapshot.direction = 'right';\n          info.snapshot.now = JogDial.utils.extend({},info.now);\n          info.snapshot.old = JogDial.utils.extend({},info.old);\n        }\n          rotation = opt.maxDegree;\n          radian = JogDial.utils.convertClockToUnit(rotation);\n          degree = JogDial.utils.convertUnitToClock(radian);\n      }\n      else if(opt.minDegree != null && opt.minDegree >= rotation){\n        if(info.snapshot.direction == null){\n          info.snapshot.direction = 'left';\n          info.snapshot.now = JogDial.utils.extend({},info.now);\n          info.snapshot.old = JogDial.utils.extend({},info.old);\n        }\n          rotation = opt.minDegree;\n          radian = JogDial.utils.convertClockToUnit(rotation);\n          degree = JogDial.utils.convertUnitToClock(radian);\n      }\n      else if(info.snapshot.direction != null){\n        info.snapshot.direction = null;\n      }\n\n      // Update JogDial data information\n      JogDial.utils.extend(self.knob, {\n        rotation: rotation,\n        degree: degree\n      });\n\n      // update angle\n      angleTo(self, radian);\n    }\n  }\n\n  // mouseDragEvent (MOUSE_UP, MOUSE_OUT)\n  function mouseUpEvent() {\n    if(self.pressed){\n      self.pressed = false;\n      if(self.info.snapshot.direction != null){\n        self.info.now = JogDial.utils.extend({},info.snapshot.now);\n        self.info.old = JogDial.utils.extend({},info.snapshot.old);\n        self.info.snapshot.direction = null;\n      }\n\n      // Trigger up event\n      JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_UP);\n    }\n  }\n}\n\n/*\n* Function\n* @param  {HTMLElement}    self\n* @param  {String}         radian\n*/\nfunction angleTo(self, radian, triggeredDegree) {\n  radian *= JogDial.ToRad;\n  const _x = Math.cos(radian) * self.radius + self.center.x,\n    _y = Math.sin(radian) * self.radius + self.center.y,\n    quadrant = JogDial.utils.getQuadrant(_x, _y),\n    degree = JogDial.utils.convertUnitToClock(radian);\n  self.knob.style.left = _x + 'px';\n  self.knob.style.top = _y + 'px';\n\n  if(self.knob.rotation === undefined){\n   // Update JogDial data information\n    JogDial.utils.extend(self.knob, {\n      rotation: self.opt.degreeStartAt,\n      degree: JogDial.utils.convertUnitToClock(radian)\n    });\n  }\n\n  if(triggeredDegree){\n    // Update JogDial data information\n    self.info.now = JogDial.utils.extend({},{rotation:triggeredDegree, quadrant: quadrant});\n    self.info.old = JogDial.utils.extend({},{rotation: triggeredDegree%360, quadrant: quadrant});\n    JogDial.utils.extend(self.knob, {\n      rotation: triggeredDegree,\n      degree: triggeredDegree%360\n    });\n  }\n\n  // Trigger move event\n  JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_MOVE);\n}\n\nexport default JogDial;\n","const tf = require('@tensorflow/tfjs');\r\n\r\nexport function efd(polygon, order=10) {\r\n  if (typeof order !== \"number\") return Promise.reject(new Error('Please provide an integer as order argument.'));\r\n  polygon = tf.tensor(polygon);\r\n\r\n  const nextPoints = polygon.slice([0], [polygon.shape[0] - 1]);\r\n  const pointDistances = polygon.slice([1]).sub(nextPoints);\r\n\r\n  const epsilon = tf.scalar(1e-16);\r\n\r\n  let lengths = pointDistances.square();\r\n  lengths = lengths.sum(1)\r\n    .add(epsilon)\r\n    .sqrt()\r\n    .sub(epsilon);\r\n\r\n  let cumulativeLengths = lengths.cumsum(0);\r\n  const zeros = tf.zeros([1]);\r\n  cumulativeLengths = tf.concat([zeros, cumulativeLengths]);\r\n  const total_distance = tf.max(cumulativeLengths);\r\n  let normalizedDistances = tf.div(tf.mul(Math.PI * 2, cumulativeLengths), total_distance);\r\n\r\n  const efdOrders = tf.range(1, order + 1).reshape([order, 1]);\r\n  const denominator = tf.square(efdOrders).mul(2).mul(tf.square(Math.PI));\r\n  let constants = total_distance.div(denominator);\r\n  constants = tf.squeeze(constants);\r\n  normalizedDistances = efdOrders.matMul(normalizedDistances.reshape([1, -1]));\r\n\r\n  const normDistX = normalizedDistances.slice([0, 1], [normalizedDistances.shape[0], normalizedDistances.shape[1] - 1]);\r\n  const normDistY = normalizedDistances.slice([0, 0], [normalizedDistances.shape[0], normalizedDistances.shape[1] - 1]);\r\n  const d_cos_phi = tf.cos(normDistX).sub(tf.cos(normDistY));\r\n  const d_sin_phi = tf.sin(normDistX).sub(tf.sin(normDistY));\r\n\r\n  const xDistances = pointDistances.slice([0, 0], [pointDistances.shape[0], 1]).squeeze();\r\n  const yDistances = pointDistances.slice([0, 1], [pointDistances.shape[0], 1]).squeeze();\r\n\r\n  const cos_phi = xDistances\r\n    .mul(d_cos_phi)\r\n    .div(lengths);\r\n\r\n  const aCoeffs = constants.mul(cos_phi.sum(1));\r\n\r\n  const bCoeffs = constants.mul(\r\n    xDistances.div(lengths)\r\n      .mul(d_sin_phi)\r\n      .sum(1)\r\n  );\r\n\r\n  const cCoeffs = constants.mul(\r\n    yDistances.div(lengths)\r\n      .mul(d_cos_phi)\r\n      .sum(1)\r\n  );\r\n\r\n  const dCoeffs = constants.mul(yDistances.div(lengths)\r\n    .mul(d_sin_phi)\r\n    .sum(1));\r\n\r\n  const coeffs = tf.stack([\r\n    aCoeffs,\r\n    bCoeffs,\r\n    cCoeffs,\r\n    dCoeffs\r\n  ]).transpose();\r\n\r\n  // returns a Promise\r\n  return coeffs.array()\r\n}\r\n\r\nexport function efdOffsets(polygon) {\r\n  polygon = tf.tensor(polygon);\r\n\r\n  const nextPoints = polygon.slice([0], [polygon.shape[0] - 1]);\r\n  const pointDistances = polygon.slice([1]).sub(nextPoints);\r\n\r\n  const epsilon = tf.scalar(1e-16);\r\n\r\n  let lengths = pointDistances.square();\r\n  lengths = lengths.sum(1)\r\n    .add(epsilon)\r\n    .sqrt()\r\n    .sub(epsilon);\r\n\r\n  let cumulativeLengths = lengths.cumsum(0);\r\n  const zeros = tf.zeros([1]);\r\n  cumulativeLengths = tf.concat([zeros, cumulativeLengths]);\r\n  const total_distance = tf.max(cumulativeLengths);\r\n\r\n  let xDistances = pointDistances.slice([0, 0], [pointDistances.shape[0], 1])\r\n    .squeeze();\r\n  let yDistances = pointDistances.slice([0, 1], [pointDistances.shape[0], 1])\r\n    .squeeze();\r\n\r\n  // xi = np.cumsum(dxy[:, 0]) - (dxy[:, 0] / dt) * t[1:]\r\n  const xi = xDistances.cumsum()\r\n    .sub(\r\n      xDistances.div(lengths).mul(cumulativeLengths.slice([1], [cumulativeLengths.shape[0] - 1])));\r\n\r\n  // A0 = (1 / T) * np.sum(((dxy[:, 0] / (2 * dt)) * np.diff(t ** 2)) + xi * dt)\r\n  const squaredDiff = cumulativeLengths.square()\r\n    .slice([1], [cumulativeLengths.shape[0] - 1])\r\n    .sub(\r\n      cumulativeLengths.square().slice([0], [cumulativeLengths.shape[0] - 1])\r\n    );\r\n  const A0 = tf.scalar(1.).div(total_distance).mul(\r\n    xDistances.div(tf.scalar(2.).mul(lengths))\r\n      .mul(squaredDiff)\r\n      .add(xi.mul(lengths))\r\n      .sum()\r\n  );\r\n\r\n  // delta = np.cumsum(dxy[:, 1]) - (dxy[:, 1] / dt) * t[1:]\r\n  const delta = yDistances.cumsum()\r\n    .sub(\r\n      yDistances.div(lengths)\r\n        .mul(cumulativeLengths.slice([1], cumulativeLengths.shape[0] - 1))\r\n    );\r\n\r\n  // C0 = (1 / T) * np.sum(((dxy[:, 1] / (2 * dt)) * np.diff(t ** 2)) + delta * dt)\r\n  const C0 = tf.scalar(1.).div(total_distance)\r\n    .mul(\r\n      yDistances.div(tf.scalar(2.).mul(lengths))\r\n        .mul(squaredDiff)\r\n        .add(delta.mul(lengths))\r\n        .sum()\r\n    );\r\n  //\r\n  // # A0 and CO relate to the first point of the contour array as origin.\r\n  //   # Adding those values to the coefficients to make them relate to true origin.\r\n  //   return contour[0, 0] + A0, contour[0, 1] + C0\r\n  const offsets = tf.concat([\r\n    polygon.slice([0, 0], [1, 1]).add(A0),\r\n    polygon.slice([0, 1], [1, 1]).add(C0)],\r\n    ).squeeze();\r\n  return offsets.array();\r\n}\r\n\r\nexport function reconstructEllipses(coefficients, numberOfPoints=200) {\r\n  let coeffsTensor = tf.tensor(coefficients);\r\n  const order = coeffsTensor.shape[0];\r\n  const orders = tf.range(1, order + 1).reshape([-1, 1]);\r\n\r\n  const t = tf.linspace(0, 1.0, numberOfPoints);\r\n  const orderPhases = orders.mul(tf.scalar(2))\r\n    .mul(tf.scalar(Math.PI))\r\n    .mul(t.reshape([1, -1]));\r\n\r\n  const xtAll = coeffsTensor.slice([0, 0], [coeffsTensor.shape[0], 1])\r\n    .mul(tf.cos(orderPhases))\r\n    .add(\r\n      coeffsTensor.slice([0, 1], [coeffsTensor.shape[0], 1])\r\n        .mul(tf.sin(orderPhases))\r\n    );\r\n\r\n  const ytAll = coeffsTensor.slice([0, 2], [coeffsTensor.shape[0], 1])\r\n    .mul(tf.cos(orderPhases))\r\n    .add(\r\n      coeffsTensor.slice([0, 3], [coeffsTensor.shape[0], 1])\r\n        .mul(tf.sin(orderPhases))\r\n    );\r\n\r\n  return tf.stack([xtAll, ytAll], 2);\r\n}\r\n\r\nexport function reconstructPolygon(coefficients, locus=[0., 0.], numberOfPoints=200) {\r\n  const locusTensor = tf.tensor(locus);\r\n  const ellipses = reconstructEllipses(coefficients, numberOfPoints);\r\n\r\n  const reconstruction = ellipses.sum(0)\r\n      .add(locusTensor);\r\n  return reconstruction.array();\r\n}","import {efd, efdOffsets, reconstructEllipses, reconstructPolygon} from \"./efdCoefficients\";\r\nimport updateRows from \"./tableRowsFromCoefficients\";\r\nimport {animateEllipses, drawReconstruction} from \"./polygonMap\";\r\n\r\nexport default function extractPolygon(coords, numberOfEllipses) {\r\n  const locusBox = document.getElementById('locus');\r\n  const tableBody = document.getElementById('coefficients_table_body');\r\n\r\n  let offsets, coefficients;\r\n  const numberOfPoints = 200;\r\n\r\n  return Promise.all([\r\n    efdOffsets(coords),\r\n    efd(coords, numberOfEllipses)\r\n  ]).then((resultsArray) => {\r\n      [offsets, coefficients] = resultsArray;\r\n      locusBox.value = offsets.map(offset => offset.toPrecision(6));\r\n      updateRows(tableBody, coefficients);\r\n\r\n      return reconstructPolygon(coefficients, offsets, numberOfPoints);\r\n    }).then((reconstruction) => drawReconstruction(reconstruction))\r\n      // Get the individual ellipses\r\n      .then(() => reconstructEllipses(coefficients, numberOfPoints))\r\n      .then((ellipses) => ellipses.array())\r\n      .then((ellipses) => animateEllipses(window.animationItems, ellipses, offsets))\r\n      .catch(console.error);\r\n}\r\n","import {reconstructEllipses, reconstructPolygon} from \"./efdCoefficients\";\r\nimport {animateEllipses, drawReconstruction} from \"./polygonMap\";\r\n\r\nexport default function updateRows(tableBody, coefficients) {\r\n  tableBody.innerHTML = '';\r\n\r\n  return coefficients.forEach((ellipse) => {\r\n    const tableRow = tableBody.insertRow();\r\n\r\n    return ellipse.forEach((coefficient) => {\r\n      const newCell = tableRow.insertCell(-1);\r\n      newCell.innerHTML = `\r\n<input  type=\"text\" \r\n        value=\"${coefficient.toPrecision(7)}\" \r\n        oninput=\"updateTableEvent();\"\r\n        style=\"width: 108px\"/>\r\n`;\r\n    });\r\n  });\r\n}\r\n\r\nwindow.updateTableEvent = function () {\r\n  const tableRows = document.querySelectorAll('#coefficients_table_body tr');\r\n  const locusBox = document.getElementById('locus');\r\n\r\n  const offsets = locusBox.value\r\n    .split(',')\r\n    .map(Number);\r\n  let coefficients = [];\r\n\r\n  tableRows.forEach(row => {\r\n    const rowInputs = row.querySelectorAll('input');\r\n    const ellipseCoeffs = Array.from(rowInputs).map(input => Number(input.value));\r\n    coefficients.push(ellipseCoeffs);\r\n  });\r\n\r\n  return reconstructPolygon(coefficients, offsets)\r\n    .then((reconstruction) => {\r\n      drawReconstruction(reconstruction);\r\n      // Get the individual ellipses\r\n\r\n      const ellipses = reconstructEllipses(coefficients);\r\n      return ellipses.array()\r\n    })\r\n  .then((ellipses) => {\r\n    return animateEllipses(window.animationItems, ellipses, offsets)\r\n  }).catch(console.error);\r\n};\r\n","import {animateEllipses, drawReconstruction, initMap} from './polygonMap';\r\nimport JogDial from './jogDial';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport 'bootstrap';\r\nimport L from \"leaflet\";\r\nimport extractPolygon from \"./extractPolygon\";\r\n\r\nconst {map, drawnItems, reconstructionItems, animationItems} = initMap();\r\n// expose to global window state\r\nwindow.animationItems = animationItems;\r\nwindow.reconstructionItems = reconstructionItems;\r\nconst numEllipsesInput = document.getElementById('num_ellipses');\r\n\r\nlet didUserChangeEllipsesInputManually = false;\r\n\r\nmap.on(L.Draw.Event.CREATED, (event) => {\r\n  drawnItems.eachLayer((layer) => drawnItems.removeLayer(layer));\r\n  const layer = event.layer;\r\n  drawnItems.addLayer(layer);\r\n\r\n  const drawnPoints = event.layer.editing.latlngs[0][0]\r\n    .map(latLng => [latLng.lat, latLng.lng]);\r\n\r\n  const numberOfEllipses = Number(numEllipsesInput.value);\r\n\r\n  return extractPolygon(drawnPoints, numberOfEllipses, reconstructionItems, animationItems)\r\n    .then(() => console.log('Done'))\r\n    .catch(console.error)\r\n});\r\n\r\n// Construct and register ellipses jog dial\r\nconst options = {\r\n  debug: false,\r\n  wheelSize: \"80%\",\r\n  minDegree: 1,\r\n  maxDegree: 99999\r\n};\r\n\r\nconst ellipsesJogDialElement = document.getElementById('ellipses_jog_dial');\r\n// const coefficientHeadingElement = document.getElementById('coefficient_heading');\r\n\r\nfunction updateEllipses(numberOfEllipses) {\r\n  // coefficientHeadingElement.innerText = 'Ellipsis coefficients (working)';\r\n  numEllipsesInput.value = numberOfEllipses;\r\n\r\n  let layers = [];\r\n  drawnItems.eachLayer((layer) => layers.push(layer));\r\n  const drawnPoints = layers[0].editing.latlngs[0][0]\r\n    .map(latLng => [latLng.lat, latLng.lng]);\r\n\r\n  drawnPoints.push(drawnPoints[0]); // Append start->closing point to create fully closed polygon contour\r\n  return extractPolygon(drawnPoints, numberOfEllipses, reconstructionItems, animationItems)\r\n}\r\n\r\nconst ellipsesJogDial = JogDial(ellipsesJogDialElement, options)\r\n  .on(\"mouseup\", (event) => {\r\n    const numberOfEllipses = Math.round(event.target.rotation * 0.25);\r\n\r\n    return updateEllipses(numberOfEllipses)\r\n      .then(() => console.log('Done'))\r\n      .catch(console.error);\r\n  })\r\n  .on( \"mousemove\", (event) => {\r\n    if (!didUserChangeEllipsesInputManually) {\r\n      numEllipsesInput.value = Math.round(event.target.rotation * 0.25);\r\n    }\r\n    didUserChangeEllipsesInputManually = false;\r\n  });\r\n\r\nnumEllipsesInput.oninput = () => {\r\n  didUserChangeEllipsesInputManually = true;\r\n  const numberOfEllipses = Number(numEllipsesInput.value);\r\n  ellipsesJogDial.angle(numberOfEllipses * 4);\r\n\r\n  return updateEllipses(numberOfEllipses)\r\n    .catch(console.error);\r\n};\r\n","\nvar content = require(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Imports\nvar getUrl = require(\"../../node_modules/css-loader/dist/runtime/getUrl.js\");\nvar ___CSS_LOADER_URL___0___ = getUrl(require(\"./img/base_one_bg.png\"));\nvar ___CSS_LOADER_URL___1___ = getUrl(require(\"./img/base_one_knob.png\"));\n// Module\nexports.push([module.id, \"#dials {\\r\\n    height: 320px;\\r\\n    overflow: hidden;\\r\\n}\\r\\n\\r\\n.dial {\\r\\n    display: block;\\r\\n    position: relative;\\r\\n    height: 320px;\\r\\n}\\r\\n\\r\\n.dial.hidden {\\r\\n    display: none;\\r\\n}\\r\\n\\r\\n#ellipses_jog_dial {\\r\\n    position: relative;\\r\\n    width: 260px;\\r\\n    height: 260px;\\r\\n    margin: 20px auto;\\r\\n    background: url(\" + ___CSS_LOADER_URL___0___ + \") no-repeat;\\r\\n}\\r\\n#ellipses_jog_dial #ellipses_jog_dial_knob {\\r\\n    background: url(\" + ___CSS_LOADER_URL___1___ + \") no-repeat;\\r\\n}\\r\\n\", \"\"]);\n","module.exports = __webpack_public_path__ + \"images/558502491546f3959097267749723121.png\";"],"sourceRoot":""}