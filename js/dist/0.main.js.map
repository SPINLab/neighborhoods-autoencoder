{"version":3,"sources":["webpack:///./js/src/img/base_one_knob.png","webpack:///./js/src/polygonMap.js","webpack:///./js/src/jogDial.js","webpack:///./js/src/efdCoefficients.js","webpack:///./js/src/main.js","webpack:///./js/src/tableRowsFromCoefficients.js","webpack:///./js/src/main.css?59e5","webpack:///./js/src/main.css","webpack:///./js/src/img/base_one_bg.png"],"names":["module","exports","__webpack_require__","p","samplePolygon","leaflet_src_default","a","polygon","animateEllipses","featureGroup","ellipses","locus","clearLayers","locusTensor","tf_esm","firstEllipse","add","ellipsesTensor","slice","length","arraySync","pointSets","transpose","timeout","drawEllipses","pointIndex","setTimeout","pointSetTensor","forEach","ellipse","ellipseIndex","ellipseTensor","centroid","offsetSum","sum","mean","ellipsePoly","color","addLayer","plotEllipse","target","line","polyline","plotLine","document","getElementById","checked","endpoint","_map","panTo","eachLayer","layer","setStyle","opacity","options","fillOpacity","removeLayer","JogDial","element","Instance","angleTo","self","radian","triggeredDegree","ToRad","_x","Math","cos","radius","center","x","_y","sin","y","quadrant","utils","getQuadrant","convertUnitToClock","knob","style","left","top","undefined","rotation","extend","opt","degreeStartAt","degree","info","now","old","triggerEvent","CustomEvent","MOUSE_MOVE","el","getAttribute","window","alert","Ready","Doc","PI","ToDeg","ModernEvent","MobileRegEx","MobileEvent","navigator","userAgent","match","PointerEvent","pointerEnabled","msPointerEnabled","Defaults","debug","touchMode","knobSize","wheelSize","zIndex","minDegree","maxDegree","DegInfo","DomEvent","MOUSE_DOWN","MOUSE_OUT","MOUSE_UP","src","key","getComputedStyle","prop","getPropertyValue","currentStyle","getCoordinates","e","rect","event","srcElement","getBoundingClientRect","targetTouches","clientX","clientY","getRotation","newDegree","delta","checkBoxCollision","bound","point","x1","x2","y1","y2","addEvent","type","handler","capture","split","i","addEventListener","attachEvent","removeEvent","removeEventListener","detachEvent","evt","createEvent","initEvent","dispatchEvent","createEventObject","fireEvent","convertClockToUnit","n","base","setAttribute","snapshot","direction","setInstance","this","KRad","WRad","WMargnLT","WMargnTP","item","BId","BW","clientWidth","BH","clientHeight","K","createElement","W","wheel","KS","WS","position","appendChild","width","height","margin","backgroundColor","filter","webkitBorderRadius","borderRadius","setDebug","setStage","mouseDragEvent","pressed","preventDefault","returnValue","offset","offsetLeft","offsetTop","atan2","mouseUpEvent","setEvents","prototype","on","listener","off","trigger","data","angle","deg","jogDial","tf","efd","order","Promise","reject","Error","nextPoints","tensor","shape","pointDistances","sub","epsilon","scalar","lengths","square","cumulativeLengths","sqrt","cumsum","zeros","concat","total_distance","max","normalizedDistances","div","mul","efdOrders","range","reshape","denominator","constants","squeeze","normDistX","matMul","normDistY","d_cos_phi","d_sin_phi","xDistances","yDistances","cos_phi","aCoeffs","bCoeffs","cCoeffs","dCoeffs","stack","array","efdOffsets","xi","squaredDiff","A0","C0","reconstructEllipses","coefficients","numberOfPoints","coeffsTensor","orders","t","linspace","orderPhases","xtAll","ytAll","map","main_map","drawnItems","main_drawnItems","reconstructionItems","main_reconstructionItems","animationItems","main_animationItems","Icon","Default","_getIconUrl","mergeOptions","iconRetinaUrl","iconUrl","shadowUrl","addTo","control","mousePosition","addControl","Control","Draw","draw","allowIntersection","showArea","rectangle","circle","marker","circlemarker","edit","setView","initMap","numEllipsesInput","tableBody","locusBox","didUserChangeEllipsesInputManually","extractPolygon","coords","numberOfEllipses","offsets","all","then","resultsArray","value","toPrecision","innerHTML","tableRow","insertRow","coefficient","newCell","insertCell","cellContents","createTextNode","updateRows","reconstructPolygon","reconstruction","coordinates","reconstructionPolygon","drawReconstruction","console","log","Event","CREATED","drawnPoints","editing","latlngs","latLng","lat","lng","Number","catch","error","updateEllipses","layers","push","ellipsesJogDial","round","oninput","content","hmr","transform","insertInto","locals","getUrl","___CSS_LOADER_URL___0___","___CSS_LOADER_URL___1___"],"mappings":"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","file":"0.main.js","sourcesContent":["module.exports = __webpack_public_path__ + \"images/19ebf71bfa54623f9bce179b1397b1f4.png\";","import L from 'leaflet';\r\nimport 'leaflet/dist/leaflet.css';\r\nimport 'leaflet-draw';\r\nimport 'leaflet-draw/dist/leaflet.draw.css';\r\nimport 'leaflet-mouse-position';\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nconst samplePolygon = L.polygon([\r\n  [-4.042968750000001, 2.1176816099851083],\r\n  [-1.634765490889549, 4.924589343401756],\r\n  [ 2.513672411441803, 5.204741041764144],\r\n  [ 7.576171606779099, 4.854532792931999],\r\n  [ 7.576171606779099, 3.258983314545306],\r\n  [ 5.994140356779099, 1.2391610649483282],\r\n  [ 4.412109106779099, 1.5203286348304514],\r\n  [ 3.498047143220902, 2.574327983494544],\r\n  [ 1.792968884110451, 3.048365584499324],\r\n  [ 1.335937902331352, 1.4324671960870323],\r\n  [ 2.636718750000000, 0.21972602392080884],\r\n  [ 4.886719286441804, -0.008788928355074324],\r\n  [ 6.591796875000001, -1.8014609294680355],\r\n  [ 6.082030981779099, -3.188782496583868],\r\n  [ 4.130859375000001, -4.749434858640033],\r\n  [ 1.001953259110450, -3.9256363494468745],\r\n  [-2.320312634110451, -3.5923720419631144],\r\n  [-3.849609307944774, -1.5027572298285927],\r\n]);\r\n\r\nexport function initMap() {\r\n  /* This code is needed to properly load the images in the Leaflet CSS */\r\n  delete L.Icon.Default.prototype._getIconUrl;\r\n\r\n  L.Icon.Default.mergeOptions({\r\n    iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\r\n    iconUrl: require('leaflet/dist/images/marker-icon.png'),\r\n    shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\r\n  });\r\n\r\n  const map = L.map('map');\r\n\r\n  const reconstructionItems = L.featureGroup().addTo(map);\r\n  const animationItems = L.featureGroup().addTo(map);\r\n  const drawnItems = L.featureGroup().addTo(map);\r\n  drawnItems.addLayer(samplePolygon);\r\n\r\n  // Controls\r\n  L.control.mousePosition().addTo(map);\r\n  map.addControl(new L.Control.Draw({\r\n    draw: {\r\n      polygon: {\r\n        allowIntersection: false,\r\n        showArea: false\r\n      },\r\n      polyline : false,\r\n      rectangle : false,\r\n      circle : false,\r\n      marker: false,\r\n      circlemarker: false\r\n    },\r\n    edit: false\r\n  }));\r\n\r\n  const defaultCenter = [2, 0];\r\n  const defaultZoom = 5;\r\n  map.setView(defaultCenter, defaultZoom);\r\n\r\n  return {map, drawnItems, reconstructionItems, animationItems}\r\n}\r\n\r\nexport function drawReconstruction(featureGroup, coordinates) {\r\n  featureGroup.eachLayer((layer) => {\r\n    layer.setStyle({\r\n      opacity: layer.options.opacity ? layer.options.opacity * 0.3 : 0.5,\r\n      fillOpacity: layer.options.fillOpacity ? layer.options.fillOpacity * 0.3 : 0.1\r\n    })\r\n  });\r\n  const reconstructionPolygon = L.polygon(coordinates, {color: 'orange'});\r\n  featureGroup.addLayer(reconstructionPolygon);\r\n}\r\n\r\nexport function animateEllipses(featureGroup, ellipses, locus) {\r\n  featureGroup.clearLayers();\r\n\r\n  // Already add the centroid to the first polygon\r\n  const locusTensor = tf.tensor(locus);\r\n  const firstEllipse = tf.tensor([ellipses[0]])\r\n    .add(locusTensor);\r\n  // Re-assemble the offset first poly with the other polygons\r\n  const ellipsesTensor = tf.concat([\r\n    firstEllipse,\r\n    tf.tensor(ellipses.slice([1], [ellipses.length])) // auto-resolves to undefined if only one ellipse\r\n  ]);\r\n\r\n  ellipses = ellipsesTensor.arraySync();\r\n\r\n  // Draw the first polygon as is\r\n  // const ellipsePolygon = L.polygon(ellipses[0], {color: 'green'});\r\n  // featureGroup.addLayer(ellipsePolygon);\r\n  //\r\n  // Re-arrange to have list of points, each element of which contains the cooordinates for each ellipse\r\n  const pointSets = ellipsesTensor.transpose([1, 0, 2]).arraySync();\r\n  const timeout = 100;\r\n\r\n  // Iterate over the points\r\n  const pointSetIndex = 0;\r\n\r\n  function drawEllipses(pointSets, pointIndex, ellipses) {\r\n    return setTimeout(() => {\r\n      const pointSetTensor = tf.tensor(pointSets[pointIndex]);\r\n\r\n      ellipses.forEach((ellipse, ellipseIndex) => {\r\n        const ellipseTensor = tf.tensor(ellipse);\r\n        let offsetSum = tf.tensor([0, 0]);\r\n\r\n        let centroid;\r\n        if (ellipseIndex > 0) {\r\n          // Compute the offset sum of the previous ellipses\r\n          offsetSum = pointSetTensor.slice([0], [ellipseIndex])\r\n            .sum(0);\r\n          centroid = offsetSum.arraySync();\r\n        } else {\r\n          centroid = ellipseTensor.mean(0).arraySync();\r\n        }\r\n\r\n        ellipse = ellipseTensor.add(offsetSum).arraySync();\r\n        plotEllipse(featureGroup, ellipse);\r\n        plotLine(featureGroup, centroid, ellipse[pointIndex]);\r\n\r\n        let isLastEllipse = ellipseIndex === ellipses.length - 1;\r\n        if (isLastEllipse) {\r\n          const followReconstruction = document.getElementById('follow_reconstruction').checked;\r\n\r\n          if (followReconstruction) {\r\n            const endpoint = pointSetTensor.sum(0).arraySync();\r\n            featureGroup._map.panTo(endpoint);\r\n          }\r\n        }\r\n      });\r\n\r\n      if (pointIndex < pointSets.length - 1){\r\n        drawEllipses(pointSets, pointIndex + 1, ellipses)\r\n      }\r\n\r\n      return featureGroup.eachLayer((layer) => {\r\n        layer.setStyle({\r\n          opacity: layer.options.opacity ? layer.options.opacity * 0.5 : 0.5,\r\n          fillOpacity: layer.options.fillOpacity ? layer.options.fillOpacity * 0.5 : 0.2\r\n        });\r\n\r\n        if (layer.options.opacity < 0.1) {\r\n          featureGroup.removeLayer(layer);\r\n        }\r\n      });\r\n    }, timeout);\r\n  }\r\n\r\n  drawEllipses(pointSets, pointSetIndex, ellipses);\r\n}\r\n\r\nfunction plotEllipse(featureGroup, ellipse) {\r\n  const ellipsePoly = L.polygon(ellipse, {color: 'green'});\r\n  featureGroup.addLayer(ellipsePoly);\r\n}\r\n\r\nfunction plotLine(featureGroup, centroid, target) {\r\n  /**\r\n   * Plots a yellow line on a feature group from a centroid to a target coordinate\r\n   */\r\n\r\n  const line = L.polyline([centroid, target], {color: 'yellow'});\r\n  return featureGroup.addLayer(line);\r\n}","// Adapted from http://www.ohsean.net/plugins/jogdial/\n\nimport './main.css';\nimport './img/base_one_bg.png';\nimport './img/base_one_knob.png';\n/*\n* JogDial.js - v 1.0\n*\n* Copyright (c) 2014 Sean Oh (ohsiwon@gmail.com)\n* Licensed under the MIT license \n*/\n\nconst JogDial = function (element, options) {\n  return new JogDial.Instance(element, options || {});\n};\n\n/*\n* Set constant values and functions\n*/\nfunction setConstants() {\n  if (JogDial.Ready) {\n    return;\n  }\n\n  // Constants\n  JogDial.Doc   = window.document;\n  JogDial.ToRad   = Math.PI / 180;\n  JogDial.ToDeg   = 180 / Math.PI;\n\n  // Detect mouse event type\n  JogDial.ModernEvent   = !!(JogDial.Doc.addEventListener);\n  JogDial.MobileRegEx   = '/Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/';\n  JogDial.MobileEvent   = ('ontouchstart' in window) && window.navigator.userAgent.match(JogDial.MobileRegEx);\n  JogDial.PointerEvent  = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled);\n\n  // Predefined options\n  JogDial.Defaults = {\n    debug : false,\n    touchMode : 'knob',  // knob | wheel\n    knobSize : '30%',\n    wheelSize : '100%',\n    zIndex : 9999,\n    degreeStartAt : 0,\n    minDegree : null,  // (null) infinity\n    maxDegree : null   // (null) infinity\n  };\n\n  // Predefined rotation info\n  JogDial.DegInfo = {\n    rotation: 0,\n    quadrant: 1\n  };\n\n  // Predefined DOM events\n  JogDial.DomEvent = {\n    MOUSE_DOWN: 'mousedown',\n    MOUSE_MOVE: 'mousemove',\n    MOUSE_OUT: 'mouseout',\n    MOUSE_UP: 'mouseup'\n  };\n\n  // Predefined custom events\n  JogDial.CustomEvent = {\n    MOUSE_DOWN: 'mousedown',\n    MOUSE_MOVE: 'mousemove',\n    MOUSE_UP: 'mouseup'\n  };\n\n  // Utilities\n  JogDial.utils  = {\n    extend : function (target, src) {\n      for (const key in src) {\n        target[key] = src[key];\n      }\n      return target;\n    },\n\n    //Return css styling\n    getComputedStyle: function (el, prop) {\n      if (window.getComputedStyle) { // W3C Standard\n        return window.getComputedStyle(el).getPropertyValue(prop);\n      }\n      else if (el.currentStyle) { // IE7 and 8\n        return el.currentStyle[prop];\n      }\n    },\n\n    //Calculating x and y coordinates\n    getCoordinates: function (e) {\n      e = e || window.event;\n      const target = e.target || e.srcElement,\n        rect = target.getBoundingClientRect(),\n        _x = ((JogDial.MobileEvent) ? e.targetTouches[0].clientX : e.clientX) - rect.left,\n        _y = ((JogDial.MobileEvent) ? e.targetTouches[0].clientY : e.clientY) - rect.top;\n      return {x:_x,y:_y};\n    },\n\n    // Return the current quadrant.\n    // Note: JogDial's Cartesian plane is flipped, hence it's returning reversed value.\n    getQuadrant: function(x, y){\n      if (x>0 && y>0) return 4;\n      else if (x<0 && y>0) return 3;\n      else if (x<0 && y<0) return 2;\n      else if (x>=0 && y<0) return 1;\n    },\n\n    // Returne the sum of rotation value\n    getRotation: function(self, quadrant, newDegree){\n      let rotation, delta = 0, info = self.info;\n      if(quadrant === 1 && info.old.quadrant === 2){ //From 360 to 0\n          delta = 360;\n        }\n        else if(quadrant === 2 && info.old.quadrant === 1){ //From 0 to 360\n          delta = -360;\n        }\n      rotation = newDegree + delta - info.old.rotation + info.now.rotation;\n      info.old.rotation = newDegree; // return 0 ~ 360\n      info.old.quadrant = quadrant; // return 1 ~ 4\n      return rotation;\n    },\n\n    //Checking collision\n    checkBoxCollision: function (bound ,point) {\n      return bound.x1 < point.x\n      && bound.x2 > point.x\n      && bound.y1 < point.y\n      && bound.y2 > point.y;\n    },\n\n    // AddEvent, cross-browser support (IE7+)\n    addEvent: function (el, type, handler, capture) {\n      type = type.split(' ');\n      for(let i=0; i < type.length; i++) {\n        if (el.addEventListener) {\n          el.addEventListener(type[i], handler, capture);\n        }\n        else if (el.attachEvent) {\n          el.attachEvent('on'+type[i], handler);\n        }\n      }\n    },\n\n    // RemoveEvent, cross-browser support (IE7+)\n    removeEvent: function (el, type, handler) {\n      type = type.split(' ');\n      for(let i=0; i < type.length; i++) {\n        if (el.addEventListener) {\n          el.removeEventListener(type[i], handler);\n        }\n        else if (el.detachEvent) {\n          el.detachEvent('on'+type[i], handler);\n        }\n      }\n    },\n\n    // triggerEvent, cross-browser support (IE7+)\n    triggerEvent: function(el, type){\n      let evt;\n      if (JogDial.Doc.createEvent) { // W3C Standard\n        evt = JogDial.Doc.createEvent(\"HTMLEvents\");\n        evt.initEvent(type, true, true);\n        el.dispatchEvent(evt);\n      }\n      else { // IE7 and 8\n        evt = JogDial.Doc.createEventObject();\n        evt.target = {};\n        JogDial.utils.extend(evt.target, el);\n        el.fireEvent('on' + type, evt);\n      }\n    },\n\n    convertClockToUnit: function (n) {\n      return n%360-90;\n    },\n\n    convertUnitToClock: function (n) {\n      return (n >= -180 && n < -90 ) ? 450+n : 90+n;\n    }\n  };\n\n  JogDial.Ready = true;\n}\n\n/**\n * Constructor\n * JogDial.Instance\n * @return  {boolean} or {JogDial.Instance}\n * @param el Html element\n * @param opt options\n */\nJogDial.Instance = function (el ,opt) {\n  // Prevent duplication\n  if (el.getAttribute('_jogDial_')) {\n    window.alert('Please Check your code:\\njogDial can not be initialized twice in a same element.');\n    return false;\n  }\n\n  // Set global contant values and functions\n  setConstants();\n\n  // Set this instance\n  setInstance(this, el, opt);\n\n  // Set stage\n  setStage(this);\n\n  // Set events\n  setEvents(this);\n\n  // Set angle\n  angleTo(this, JogDial.utils.convertClockToUnit(this.opt.degreeStartAt));\n\n  return this;\n};\n\n/*\n* Prototype inheritance\n*/\nJogDial.Instance.prototype = {\n  on: function onEvent(type, listener) {\n    JogDial.utils.addEvent(this.knob, type, listener, false);\n    return this;\n  },\n  off: function onEvent(type, listener) {\n    JogDial.utils.removeEvent(this.knob, type, listener);\n    return this;\n  },\n  trigger: function triggerEvent(type, data) {\n    if (type === 'angle') {\n      angleTo(this, JogDial.utils.convertClockToUnit(data), data);\n    } else {\n      window.alert('Please Check your code:\\njogDial does not have triggering event [' + type + ']');\n    }\n    return this;\n  },\n  angle: function angle(data) {\n    const deg = (data > this.opt.maxDegree) ? this.opt.maxDegree : data;\n    angleTo(this, JogDial.utils.convertClockToUnit(deg), deg);\n  }\n};\n\nfunction setInstance(self, el, opt){\n  self.base = el;\n  self.base.setAttribute('_JogDial_', true);\n  self.opt = JogDial.utils.extend(JogDial.utils.extend({}, JogDial.Defaults), opt);\n  self.info = {} || self;\n  self.info.now = JogDial.utils.extend({},JogDial.DegInfo);\n  self.info.old = JogDial.utils.extend({},JogDial.DegInfo);\n  self.info.snapshot = JogDial.utils.extend({},self.info);\n  self.info.snapshot.direction = null;\n}\n\nfunction setStage(self) {\n  /*\n  * Create new elements\n  * {HTMLElement}  JogDial.Instance.knob\n  * {HTMLElement}  JogDial.Instance.wheel\n  */\n  let item = {},\n    BId = self.base.getAttribute(\"id\"),\n    BW = self.base.clientWidth,\n    BH = self.base.clientHeight,\n    opt = self.opt,\n    K = item.knob = document.createElement('div'),\n    W = item.wheel = document.createElement('div'),\n    KS = K.style,\n    WS = W.style,\n    KRad, WRad, WMargnLT, WMargnTP;\n\n  //Set position property as relative if it's not predefined in Stylesheet\n  if (JogDial.utils.getComputedStyle(self.base, 'position') === 'static') {\n    self.base.style.position = 'relative';\n  }\n\n  //Append to base and extend {object} item\n  self.base.appendChild(K);\n  self.base.appendChild(W);\n  JogDial.utils.extend(self, item);\n\n  //Set global position and size\n  KS.position = WS.position = 'absolute';\n  KS.width = KS.height = opt.knobSize;\n  WS.width = WS.height = opt.wheelSize;\n\n  //Set radius value\n  KRad = K.clientWidth/2;\n  WRad = W.clientWidth/2;\n\n  //Set knob properties\n  K.setAttribute('id', BId + '_knob');\n  KS.margin = -KRad + 'px 0 0 ' + -KRad + 'px';\n  KS.zIndex = opt.zIndex;\n\n  //Set wheel properties\n  W.setAttribute('id', BId + '_wheel');\n\n  WMargnLT = (BW-W.clientWidth)/2;\n  WMargnTP = (BH-W.clientHeight)/2;\n\n  WS.left = WS.top = 0;\n  WS.margin = WMargnTP + 'px 0 0 ' + WMargnLT + 'px';\n  WS.zIndex = opt.zIndex;\n\n  //set radius and center point value\n  self.radius = WRad - KRad;\n  self.center = {x:WRad+WMargnLT, y:WRad+WMargnTP};\n\n  //Set debug mode\n  if (opt.debug) setDebug(self);\n}\n\nfunction setDebug(self) {\n  const KS = self.knob.style;\n  const WS = self.wheel.style;\n  KS.backgroundColor = '#00F';\n  WS.backgroundColor = '#0F0';\n  KS.opacity = WS.opacity = .4;\n  KS.filter = WS.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=40)';\n\n  //Fancy CSS3 for debug\n  KS.webkitBorderRadius = WS.webkitBorderRadius = \"50%\";\n  KS.borderRadius = WS.borderRadius = \"50%\";\n}\n\nfunction setEvents(self) {\n  /*\n  * Set events to control elements\n  * {HTMLElement}  JogDial.Instance.knob\n  * {HTMLElement}  JogDial.Instance.wheel\n  */\n\n  //Detect event support type and override values\n  if (JogDial.PointerEvent) { // Windows 8 touchscreen\n    JogDial.utils.extend(JogDial.DomEvent,{\n      MOUSE_DOWN: 'pointerdown MSPointerDown',\n      MOUSE_MOVE: 'pointermove MSPointerMove',\n      MOUSE_OUT: 'pointerout MSPointerOut',\n      MOUSE_UP: 'pointerup pointercancel MSPointerUp MSPointerCancel'\n    });\n  }\n  else if (JogDial.MobileEvent) { // Mobile standard\n    JogDial.utils.extend(JogDial.DomEvent,{\n      MOUSE_DOWN: 'touchstart',\n      MOUSE_MOVE: 'touchmove',\n      MOUSE_OUT: 'touchleave',\n      MOUSE_UP: 'touchend'\n    });\n  }\n\n  const opt = self.opt,\n    info = self.info,\n    K = self.knob,\n    W = self.wheel;\n  self.pressed = false;\n\n  // Add events\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_DOWN, mouseDownEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_MOVE, mouseDragEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_UP, mouseUpEvent, false);\n  JogDial.utils.addEvent(W, JogDial.DomEvent.MOUSE_OUT, mouseUpEvent, false);\n\n  // mouseDownEvent (MOUSE_DOWN)\n  function mouseDownEvent(e) {\n    switch (opt.touchMode) {\n      case 'knob':\n      default:\n        self.pressed = JogDial.utils.checkBoxCollision({\n          x1: K.offsetLeft - W.offsetLeft,\n          y1: K.offsetTop - W.offsetTop,\n          x2: K.offsetLeft - W.offsetLeft + K.clientWidth,\n          y2:  K.offsetTop - W.offsetTop + K.clientHeight\n          }, JogDial.utils.getCoordinates(e));\n        break;\n      case 'wheel':\n        self.pressed = true;\n        mouseDragEvent(e);\n        break;\n    }\n\n    //Trigger down event\n    if(self.pressed) JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_DOWN);\n  }\n\n  // mouseDragEvent (MOUSE_MOVE)\n  function mouseDragEvent(e) {\n    if (self.pressed) {\n      // Prevent default event\n      (e.preventDefault) ? e.preventDefault() : e.returnValue = false;\n\n      // var info = self.info, opt = self.opt,\n      let offset = JogDial.utils.getCoordinates(e),\n        _x = offset.x - self.center.x + W.offsetLeft,\n        _y = offset.y - self.center.y + W.offsetTop,\n        radian = Math.atan2(_y, _x) * JogDial.ToDeg,\n        quadrant = JogDial.utils.getQuadrant(_x, _y),\n        degree = JogDial.utils.convertUnitToClock(radian),\n        rotation;\n\n      //Calculate the current rotation value based on pointer offset\n      info.now.rotation = JogDial.utils.getRotation(self, (quadrant === undefined) ? info.old.quadrant : quadrant  , degree);\n      rotation = info.now.rotation;//Math.ceil(info.now.rotation);\n\n      if(opt.maxDegree != null && opt.maxDegree <= rotation){\n        if(info.snapshot.direction == null){\n          info.snapshot.direction = 'right';\n          info.snapshot.now = JogDial.utils.extend({},info.now);\n          info.snapshot.old = JogDial.utils.extend({},info.old);\n        }\n          rotation = opt.maxDegree;\n          radian = JogDial.utils.convertClockToUnit(rotation);\n          degree = JogDial.utils.convertUnitToClock(radian);\n      }\n      else if(opt.minDegree != null && opt.minDegree >= rotation){\n        if(info.snapshot.direction == null){\n          info.snapshot.direction = 'left';\n          info.snapshot.now = JogDial.utils.extend({},info.now);\n          info.snapshot.old = JogDial.utils.extend({},info.old);\n        }\n          rotation = opt.minDegree;\n          radian = JogDial.utils.convertClockToUnit(rotation);\n          degree = JogDial.utils.convertUnitToClock(radian);\n      }\n      else if(info.snapshot.direction != null){\n        info.snapshot.direction = null;\n      }\n\n      // Update JogDial data information\n      JogDial.utils.extend(self.knob, {\n        rotation: rotation,\n        degree: degree\n      });\n\n      // update angle\n      angleTo(self, radian);\n    }\n  }\n\n  // mouseDragEvent (MOUSE_UP, MOUSE_OUT)\n  function mouseUpEvent() {\n    if(self.pressed){\n      self.pressed = false;\n      if(self.info.snapshot.direction != null){\n        self.info.now = JogDial.utils.extend({},info.snapshot.now);\n        self.info.old = JogDial.utils.extend({},info.snapshot.old);\n        self.info.snapshot.direction = null;\n      }\n\n      // Trigger up event\n      JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_UP);\n    }\n  }\n}\n\n/*\n* Function\n* @param  {HTMLElement}    self\n* @param  {String}         radian\n*/\nfunction angleTo(self, radian, triggeredDegree) {\n  radian *= JogDial.ToRad;\n  const _x = Math.cos(radian) * self.radius + self.center.x,\n    _y = Math.sin(radian) * self.radius + self.center.y,\n    quadrant = JogDial.utils.getQuadrant(_x, _y),\n    degree = JogDial.utils.convertUnitToClock(radian);\n  self.knob.style.left = _x + 'px';\n  self.knob.style.top = _y + 'px';\n\n  if(self.knob.rotation === undefined){\n   // Update JogDial data information\n    JogDial.utils.extend(self.knob, {\n      rotation: self.opt.degreeStartAt,\n      degree: JogDial.utils.convertUnitToClock(radian)\n    });\n  }\n\n  if(triggeredDegree){\n    // Update JogDial data information\n    self.info.now = JogDial.utils.extend({},{rotation:triggeredDegree, quadrant: quadrant});\n    self.info.old = JogDial.utils.extend({},{rotation: triggeredDegree%360, quadrant: quadrant});\n    JogDial.utils.extend(self.knob, {\n      rotation: triggeredDegree,\n      degree: triggeredDegree%360\n    });\n  }\n\n  // Trigger move event\n  JogDial.utils.triggerEvent(self.knob, JogDial.CustomEvent.MOUSE_MOVE);\n}\n\nexport default JogDial;\n","const tf = require('@tensorflow/tfjs');\r\n\r\nexport function efd(polygon, order=10) {\r\n  if (typeof order !== \"number\") return Promise.reject(new Error('Please provide an integer as order argument.'));\r\n  polygon = tf.tensor(polygon);\r\n\r\n  const nextPoints = polygon.slice([0], [polygon.shape[0] - 1]);\r\n  const pointDistances = polygon.slice([1]).sub(nextPoints);\r\n\r\n  const epsilon = tf.scalar(1e-16);\r\n\r\n  let lengths = pointDistances.square();\r\n  lengths = lengths.sum(1)\r\n    .add(epsilon)\r\n    .sqrt()\r\n    .sub(epsilon);\r\n\r\n  let cumulativeLengths = lengths.cumsum(0);\r\n  const zeros = tf.zeros([1]);\r\n  cumulativeLengths = tf.concat([zeros, cumulativeLengths]);\r\n  const total_distance = tf.max(cumulativeLengths);\r\n  let normalizedDistances = tf.div(tf.mul(Math.PI * 2, cumulativeLengths), total_distance);\r\n\r\n  const efdOrders = tf.range(1, order + 1).reshape([order, 1]);\r\n  const denominator = tf.square(efdOrders).mul(2).mul(tf.square(Math.PI));\r\n  let constants = total_distance.div(denominator);\r\n  constants = tf.squeeze(constants);\r\n  normalizedDistances = efdOrders.matMul(normalizedDistances.reshape([1, -1]));\r\n\r\n  const normDistX = normalizedDistances.slice([0, 1], [normalizedDistances.shape[0], normalizedDistances.shape[1] - 1]);\r\n  const normDistY = normalizedDistances.slice([0, 0], [normalizedDistances.shape[0], normalizedDistances.shape[1] - 1]);\r\n  const d_cos_phi = tf.cos(normDistX).sub(tf.cos(normDistY));\r\n  const d_sin_phi = tf.sin(normDistX).sub(tf.sin(normDistY));\r\n\r\n  const xDistances = pointDistances.slice([0, 0], [pointDistances.shape[0], 1]).squeeze();\r\n  const yDistances = pointDistances.slice([0, 1], [pointDistances.shape[0], 1]).squeeze();\r\n\r\n  const cos_phi = xDistances\r\n    .mul(d_cos_phi)\r\n    .div(lengths);\r\n\r\n  const aCoeffs = constants.mul(cos_phi.sum(1));\r\n\r\n  const bCoeffs = constants.mul(\r\n    xDistances.div(lengths)\r\n      .mul(d_sin_phi)\r\n      .sum(1)\r\n  );\r\n\r\n  const cCoeffs = constants.mul(\r\n    yDistances.div(lengths)\r\n      .mul(d_cos_phi)\r\n      .sum(1)\r\n  );\r\n\r\n  const dCoeffs = constants.mul(yDistances.div(lengths)\r\n    .mul(d_sin_phi)\r\n    .sum(1));\r\n\r\n  const coeffs = tf.stack([\r\n    aCoeffs,\r\n    bCoeffs,\r\n    cCoeffs,\r\n    dCoeffs\r\n  ]).transpose();\r\n\r\n  // returns a Promise\r\n  return coeffs.array()\r\n}\r\n\r\nexport function efdOffsets(polygon) {\r\n  polygon = tf.tensor(polygon);\r\n\r\n  const nextPoints = polygon.slice([0], [polygon.shape[0] - 1]);\r\n  const pointDistances = polygon.slice([1]).sub(nextPoints);\r\n\r\n  const epsilon = tf.scalar(1e-16);\r\n\r\n  let lengths = pointDistances.square();\r\n  lengths = lengths.sum(1)\r\n    .add(epsilon)\r\n    .sqrt()\r\n    .sub(epsilon);\r\n\r\n  let cumulativeLengths = lengths.cumsum(0);\r\n  const zeros = tf.zeros([1]);\r\n  cumulativeLengths = tf.concat([zeros, cumulativeLengths]);\r\n  const total_distance = tf.max(cumulativeLengths);\r\n\r\n  let xDistances = pointDistances.slice([0, 0], [pointDistances.shape[0], 1])\r\n    .squeeze();\r\n  let yDistances = pointDistances.slice([0, 1], [pointDistances.shape[0], 1])\r\n    .squeeze();\r\n\r\n  // xi = np.cumsum(dxy[:, 0]) - (dxy[:, 0] / dt) * t[1:]\r\n  const xi = xDistances.cumsum()\r\n    .sub(\r\n      xDistances.div(lengths).mul(cumulativeLengths.slice([1], [cumulativeLengths.shape[0] - 1])));\r\n\r\n  // A0 = (1 / T) * np.sum(((dxy[:, 0] / (2 * dt)) * np.diff(t ** 2)) + xi * dt)\r\n  const squaredDiff = cumulativeLengths.square()\r\n    .slice([1], [cumulativeLengths.shape[0] - 1])\r\n    .sub(\r\n      cumulativeLengths.square().slice([0], [cumulativeLengths.shape[0] - 1])\r\n    );\r\n  const A0 = tf.scalar(1.).div(total_distance).mul(\r\n    xDistances.div(tf.scalar(2.).mul(lengths))\r\n      .mul(squaredDiff)\r\n      .add(xi.mul(lengths))\r\n      .sum()\r\n  );\r\n\r\n  // delta = np.cumsum(dxy[:, 1]) - (dxy[:, 1] / dt) * t[1:]\r\n  const delta = yDistances.cumsum()\r\n    .sub(\r\n      yDistances.div(lengths)\r\n        .mul(cumulativeLengths.slice([1], cumulativeLengths.shape[0] - 1))\r\n    );\r\n\r\n  // C0 = (1 / T) * np.sum(((dxy[:, 1] / (2 * dt)) * np.diff(t ** 2)) + delta * dt)\r\n  const C0 = tf.scalar(1.).div(total_distance)\r\n    .mul(\r\n      yDistances.div(tf.scalar(2.).mul(lengths))\r\n        .mul(squaredDiff)\r\n        .add(delta.mul(lengths))\r\n        .sum()\r\n    );\r\n  //\r\n  // # A0 and CO relate to the first point of the contour array as origin.\r\n  //   # Adding those values to the coefficients to make them relate to true origin.\r\n  //   return contour[0, 0] + A0, contour[0, 1] + C0\r\n  const offsets = tf.concat([\r\n    polygon.slice([0, 0], [1, 1]).add(A0),\r\n    polygon.slice([0, 1], [1, 1]).add(C0)],\r\n    ).squeeze();\r\n  return offsets.array();\r\n}\r\n\r\nexport function reconstructEllipses(coefficients, numberOfPoints=200) {\r\n  let coeffsTensor = tf.tensor(coefficients);\r\n  const order = coeffsTensor.shape[0];\r\n  const orders = tf.range(1, order + 1).reshape([-1, 1]);\r\n\r\n  const t = tf.linspace(0, 1.0, numberOfPoints);\r\n  const orderPhases = orders.mul(tf.scalar(2))\r\n    .mul(tf.scalar(Math.PI))\r\n    .mul(t.reshape([1, -1]));\r\n\r\n  const xtAll = coeffsTensor.slice([0, 0], [coeffsTensor.shape[0], 1])\r\n    .mul(tf.cos(orderPhases))\r\n    .add(\r\n      coeffsTensor.slice([0, 1], [coeffsTensor.shape[0], 1])\r\n        .mul(tf.sin(orderPhases))\r\n    );\r\n\r\n  const ytAll = coeffsTensor.slice([0, 2], [coeffsTensor.shape[0], 1])\r\n    .mul(tf.cos(orderPhases))\r\n    .add(\r\n      coeffsTensor.slice([0, 3], [coeffsTensor.shape[0], 1])\r\n        .mul(tf.sin(orderPhases))\r\n    );\r\n\r\n  return tf.stack([xtAll, ytAll], 2);\r\n}\r\n\r\nexport function reconstructPolygon(coefficients, locus=[0., 0.], numberOfPoints=200) {\r\n  const locusTensor = tf.tensor(locus);\r\n  const ellipses = reconstructEllipses(coefficients, numberOfPoints);\r\n\r\n  const reconstruction = ellipses.sum(0)\r\n      .add(locusTensor);\r\n  return reconstruction.array();\r\n}","import {initMap, drawReconstruction, animateEllipses} from './polygonMap';\r\nimport JogDial from './jogDial';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport 'bootstrap';\r\nimport L from \"leaflet\";\r\nimport {efd, efdOffsets, reconstructPolygon, reconstructEllipses} from \"./efdCoefficients\";\r\nimport updateRows from \"./tableRowsFromCoefficients\";\r\n\r\nconst {map, drawnItems, reconstructionItems, animationItems} = initMap();\r\nconst numEllipsesInput = document.getElementById('num_ellipses');\r\nconst tableBody = document.getElementById('coefficients_table_body');\r\nconst locusBox = document.getElementById('locus');\r\n\r\nlet didUserChangeEllipsesInputManually = false;\r\n\r\nfunction extractPolygon(coords, numberOfEllipses) {\r\n  let offsets, coefficients;\r\n  const numberOfPoints = 200;\r\n\r\n  return Promise.all([\r\n    efdOffsets(coords),\r\n    efd(coords, numberOfEllipses)\r\n  ]).then((resultsArray) => {\r\n    [offsets, coefficients] = resultsArray;\r\n    locusBox.value = offsets.map(offset => offset.toPrecision(6));\r\n    updateRows(tableBody, coefficients);\r\n    // const numberOfPoints = coords.length;\r\n    return reconstructPolygon(coefficients, offsets, numberOfPoints);\r\n  })\r\n    .then((reconstruction) => drawReconstruction(reconstructionItems, reconstruction))\r\n    // Get the individual ellipses\r\n    .then(() => reconstructEllipses(coefficients, numberOfPoints))\r\n    .then((ellipses) => ellipses.array())\r\n    .then((ellipses) => {\r\n      console.log(ellipses);\r\n      animateEllipses(animationItems, ellipses, offsets)\r\n    })\r\n  // ;\r\n}\r\n\r\nmap.on(L.Draw.Event.CREATED, (event) => {\r\n  drawnItems.eachLayer((layer) => drawnItems.removeLayer(layer));\r\n  const layer = event.layer;\r\n  drawnItems.addLayer(layer);\r\n\r\n  const drawnPoints = event.layer.editing.latlngs[0][0]\r\n    .map(latLng => [latLng.lat, latLng.lng]);\r\n\r\n  const numberOfEllipses = Number(numEllipsesInput.value);\r\n\r\n  return extractPolygon(drawnPoints, numberOfEllipses, drawnPoints)\r\n    .then(() => console.log('Done'))\r\n    .catch(console.error)\r\n});\r\n\r\n// Construct and register ellipses jog dial\r\nconst options = {\r\n  debug: false,\r\n  wheelSize: \"80%\",\r\n  minDegree: 1,\r\n  maxDegree: 99999\r\n};\r\n\r\nconst ellipsesJogDialElement = document.getElementById('ellipses_jog_dial');\r\n// const coefficientHeadingElement = document.getElementById('coefficient_heading');\r\n\r\nfunction updateEllipses(numberOfEllipses) {\r\n  // coefficientHeadingElement.innerText = 'Ellipsis coefficients (working)';\r\n  numEllipsesInput.value = numberOfEllipses;\r\n\r\n  let layers = [];\r\n  drawnItems.eachLayer((layer) => layers.push(layer));\r\n  const drawnPoints = layers[0].editing.latlngs[0][0]\r\n    .map(latLng => [latLng.lat, latLng.lng]);\r\n\r\n  drawnPoints.push(drawnPoints[0]); // Append start->closing point to create fully closed polygon contour\r\n\r\n  return extractPolygon(drawnPoints, numberOfEllipses)\r\n}\r\n\r\nconst ellipsesJogDial = JogDial(ellipsesJogDialElement, options)\r\n  .on(\"mouseup\", (event) => {\r\n    const numberOfEllipses = Math.round(event.target.rotation * 0.25);\r\n\r\n    return updateEllipses(numberOfEllipses)\r\n      .then(() => console.log('Done'))\r\n      .catch(console.error);\r\n  })\r\n  .on( \"mousemove\", (event) => {\r\n    if (!didUserChangeEllipsesInputManually) {\r\n      numEllipsesInput.value = Math.round(event.target.rotation * 0.25);\r\n    }\r\n    didUserChangeEllipsesInputManually = false;\r\n  });\r\n\r\nnumEllipsesInput.oninput = () => {\r\n  didUserChangeEllipsesInputManually = true;\r\n  const numberOfEllipses = Number(numEllipsesInput.value);\r\n  ellipsesJogDial.angle(numberOfEllipses * 4);\r\n\r\n  return updateEllipses(numberOfEllipses)\r\n    .catch(console.error);\r\n};\r\n","export default function updateRows(tableBody, coefficients) {\r\n  tableBody.innerHTML = '';\r\n\r\n  return coefficients.forEach((ellipse) => {\r\n    const tableRow = tableBody.insertRow();\r\n\r\n    return ellipse.forEach((coefficient) => {\r\n      const newCell = tableRow.insertCell(-1);\r\n      const cellContents = document.createTextNode(coefficient.toPrecision(8));\r\n      newCell.appendChild(cellContents);\r\n    });\r\n  });\r\n}\r\n","\nvar content = require(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/dist/cjs.js!./main.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Imports\nvar getUrl = require(\"../../node_modules/css-loader/dist/runtime/getUrl.js\");\nvar ___CSS_LOADER_URL___0___ = getUrl(require(\"./img/base_one_bg.png\"));\nvar ___CSS_LOADER_URL___1___ = getUrl(require(\"./img/base_one_knob.png\"));\n// Module\nexports.push([module.id, \"#dials {\\r\\n    height: 320px;\\r\\n    overflow: hidden;\\r\\n}\\r\\n\\r\\n.dial {\\r\\n    display: block;\\r\\n    position: relative;\\r\\n    height: 320px;\\r\\n}\\r\\n\\r\\n.dial.hidden {\\r\\n    display: none;\\r\\n}\\r\\n\\r\\n#ellipses_jog_dial {\\r\\n    position: relative;\\r\\n    width: 260px;\\r\\n    height: 260px;\\r\\n    margin: 20px auto;\\r\\n    background: url(\" + ___CSS_LOADER_URL___0___ + \") no-repeat;\\r\\n}\\r\\n#ellipses_jog_dial #ellipses_jog_dial_knob {\\r\\n    background: url(\" + ___CSS_LOADER_URL___1___ + \") no-repeat;\\r\\n}\\r\\n\", \"\"]);\n","module.exports = __webpack_public_path__ + \"images/558502491546f3959097267749723121.png\";"],"sourceRoot":""}